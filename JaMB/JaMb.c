#include "house.h"
#include <string.h>
#include <ctype.h>
#undef toupper
#include <malloc.h>
#include <entlfunc.h1>
#include <window.h1>
#include <dos.h>
#include <search.h>
#include <multic.h>
#include <multicom.h>
#include <kbd.h>

/*	md_char_width is an array of the width of characters generated by the message display
	firmware.  The base entry of the table is the SPACE character (ascii 32); thus, all
	offsets are calculated with the formula (c - SPACE) */

unsigned short md_char_width[] = {
	3,	/* SPACE */
	2,	/* ! */ 	4,	/* " */ 	6,	/* # */ 	6,	/* $ */
	6,	/* % */ 	6,	/* & */ 	2,	/* ' */ 	4,	/* ( */
	4,	/* ) */ 	6,	/* * */ 	6,	/* + */ 	3,	/* , */
	6,	/* - */ 	2,	/* . */ 	6,	/* / */ 	6,	/* 0 */
	4,	/* 1 */ 	6,	/* 2 */ 	6,	/* 3 */ 	6,	/* 4 */
	6,	/* 5 */ 	6,	/* 6 */ 	6,	/* 7 */ 	6,	/* 8 */
	6,	/* 9 */ 	2,	/* : */ 	3,	/* ; */ 	5,	/* < */
	6,	/* = */ 	5,	/* > */ 	6,	/* ? */ 	6,	/* @ */
	6,	/* A */ 	6,	/* B */ 	6,	/* C */ 	6,	/* D */
	6,	/* E */ 	6,	/* F */ 	6,	/* G */ 	6,	/* H */
	4,	/* I */ 	6,	/* J */ 	6,	/* K */ 	6,	/* L */
	6,	/* M */ 	6,	/* N */ 	6,	/* O */ 	6,	/* P */
	6,	/* Q */ 	6,	/* R */ 	6,	/* S */ 	6,	/* T */
	6,	/* U */ 	6,	/* V */ 	6,	/* W */ 	6,	/* X */
	6,	/* Y */ 	6,	/* Z */ 	5,	/* [ */ 	6,	/* \ */
	5,	/* ] */ 	6,	/* ^ */ 	6	/* _ */
} ;

ENTRY order_phrases[] = {
	{ "CONSENT CALENDAR", NULL },
	{ "CALENDAR", NULL },
	{ "GENERAL ORDERS", NULL },
	{ "SPECIAL ORDERS", NULL },
	{ "RULE 1.10", NULL },
	{ "CONFERENCE", "COMMITTEE REPORT" },
	{ "MESSAGES FROM", "SENATE" },
	{ "FIRST READING", "SENATE FILES" },
	{ "FIRST READING", "HOUSE FILES" },
	{ "MOTIONS AND", "RESOLUTIONS" },
	{ "REPORT FROM", "RULES" },
	{ NULL, NULL },
};

ENTRY action_phrases[] = {
	{ "PASSAGE", NULL },
	{ "AMENDMENT", NULL },
	{ "AMENDMENT", "TO AMENDMENT" },
	{ "MOTION", NULL },
	{ "RE-REFERRAL", NULL },
	{ "CONCURRENCE", NULL },
	{ "REFUSE TO CONCUR", NULL },
	{ "ADOPTION", NULL },
	{ "RECONSIDERATION", NULL },
	{ "SUSPENSION", "OF RULES" },
	{ "APPEAL", NULL },
	{ "REFERRAL", NULL },
	{ "CALL OF HOUSE", NULL },
	{ "QUORUM CALL", NULL },
	{ "LAY ON THE TABLE", NULL },
	{ "RECOMMEND", "TO PASS" },
	{ "TEST", NULL },
	{ NULL, NULL },
};

ENTRY number_phrases[] = {
	{ "H.F. NO. ", NULL },
	{ "S.F. NO. ", NULL },
	{ "H.R. NO. ", NULL },
	{ "H.C.R. NO. ", NULL },
	{ "S.C.R. NO. ", NULL },
	{ NULL, NULL },
};


TYPE order = { 0, NULL, order_phrases, 0, " ORDERS OF BUSINESS " };

TYPE number = { 2, NULL, number_phrases, 0, " FILES/RESOLUTIONS " };

TYPE action = { 4, NULL, action_phrases, 0, " ACTIONS " };


QUEUE calendar = { 0, 0, 1, NULL, NULL, "CALENDAR" };

QUEUE consent = { 0, 0, 1, NULL, NULL, "CONSENT CALENDAR" };

QUEUE special = { 0, 0, 1, NULL, NULL, "SPECIAL ORDERS" };

QUEUE general = { 0, 0, 1, NULL, NULL, "GENERAL ORDERS" };


static char mister_speaker[] = "Spk. ";
static char yeas_nays[] = "YEAS      NAYS";
static char ed_inp_footer[] = " Return to use text, Esc to cancel. ";
static char ed_inp_prompt[] = "Enter text: ";
static char editor_footer[] = " Type Del to clear this line. ";
static char editor_prompt[] = "Ready for text: ";
static char confirm_footer[] = " Confirmation ";
static char delete_confirm[] = "Hit Del to proceed, Esc to cancel.";
static char editor_header[] = " Message Editor ";
static char phrase_prompt[] = "Enter selection number: ";
static char calendar_prompt[] = "Enter calendar selection number: ";
static char error_format[] = "No selection %d.  Try again: ";
static char blank_entry[] = "Entry %d is blank.  Try again: ";
static char number_prompt[] = "Enter the file number: ";
static char clear_area[] = " Type Del to clear this area. ";
static char clear_entry[] = " Type Del to clear this entry. ";
static char page1_footer[] = "µ 1 Æ";
static char page2_footer[] = "µ 2 Æ";
static char null_q_entry[] = "_______________";
static char queue_footer[] = " page %d of %d ";
static char next_in_queue[] = " Next item is %s. ";
static char no_next_in_queue[] = " There is no next item. ";
static char lock_header[] = " Vote Station Locking ";
static char lock_footer[] = " Type - to lock, + to unlock. ";
static char lock_list_header[] = " Locked Stations ";
static char no_name_match[] = "No match for %s.  Try again.";
static char lock_name_prompt[] = "Enter name for search:";
static char lock_current_station[] = "Current station: %s";
static char missing_parm[] = "disaster: mangled parameter file \n\007";

static char parm_fname[] = "parms.mn";
static char seating_date[7];
short session_number;

char td_huge_top[] = "\033m1\033p1";
char td_huge_bottom[] = "\033m2\033p1";
char td_cursor_address[] = "\033=%c%c";

extern int dummyadr;
extern BORDERCH bor2lin;
extern char *itoa();

int err;
char virtual_display[2][8][17];		/* 2 displays of 8 lines by 16 characters & terminating zero */
OFFSETS display_offset[2][8];		/* for centering to message display and terminals */
unsigned short active_display;		/* to determine which of the 2 displays is active */

OFFSETS result_offset[2];			/* these two arrays accomodate output to message display boards */
char virtual_result[2][17];				/* driven by vote machine communications */
char printout_header[3][40]; 		/* for xfer to vote system */

WINDOW *ww_queue_select, *ww_display[2], *ww_lock_control, *ww_lock_list;

int idle(), b_main(), vs_rx();		/* declarations for multi-c */
char *ibmdvr();					/* comm drivers */
int mssg_display, vote_system; 		/* comm channels */
int mssg_sema = 0;					/* permission to use the message boards */

int lock_page, lock_total;			/* for station lock routines */

LEX member[135];					/* list of members: loaded from seating file */



main()
{

	initmc(6,5,5);

	if (initcomm(2) < 0) {
		printf("error in initializing communications\n");
		exit(2);
	}

	no_abort();
	initclk(NULLF);

	kb_init(128);

	if ((err = tcreat(b_main, 0, 8192)) == -1) {
		printf("error in creating b_main\n");
		exit(1);
	}

	if ((err = tcreat(vs_rx, 0, 2048)) == -1) {
		printf("error in creating b_main\n");
		exit(1);
	}

	if ((err = tcreat(idle, 1, 512)) == -1) {
		printf("error in creating idle\n");
		exit(1);
	}

	startmc();
}

b_main()
{
	int loop;
	int state = ORDER_STATE;
	int old_state,result;

	/* preserve cursor somewhere */
	savcsize(9, 11);
	cursize(CURSOR_OFF, CURSOR_OFF);

	/* initialize printout header to linefeeds */
	for (loop = 0; loop < 3; loop++)
		printout_header[loop][0] = '\n';

	/* perform initializations on windows */
	if (err = init_permanent()) {
		printf("Error %d in init_permanent()\n", err);
		exit(1);
	}

	if (err = init_type(&order)) {
		printf("Error %d in init_type(&order)\n", err);
		exit(1);
	}

	if (err = init_type(&number)) {
		printf("Error %d in init_type($number)\n", err);
		exit(1);
	}

	if (err = init_type(&action)) {
		printf("Error %d in init_type(&action)\n", err);
		exit(1);
	}

	if (err = init_queue(&calendar)) {
		printf("Error %d in init_queue(&calendar)\n", err);
		exit(1);
	}

	if (err = init_queue(&consent)) {
		printf("Error %d in init_queue(&consent)\n", err);
		exit(1);
	}

	if (err = init_queue(&special)) {
		printf("Error %d in init_queue(&special)\n", err);
		exit(1);
	}

	if (err = init_queue(&general)) {
		printf("Error %d in init_queue(&general)\n", err);
		exit(1);
	}

	/* initialize output ports */

	/* message display */
	if ((mssg_display = sopen(COM2, BAUD300+NOPARITY+STOP1+BITS8, ibmdvr)) < 0) {
		printf("init message display disaster\n");
		exit(2);
	}
	srxto(mssg_display, 18);
	stxto(mssg_display, 18);

	/* vote system */
	if ((vote_system = sopen(COM1, BAUD9600+NOPARITY+STOP1+BITS8, ibmdvr)) < 0) {
		printf("init vote system disaster\n");
		exit(2);
	}
	srxto(vote_system, 0);
	stxto(vote_system, 27);

	/* terminal displays */
	prn_init();

	/* read parameter file and set up seating chart */
	load_parm_file();
	pause();

	load_seating();
	pause();


/* M A I N   L O O P   O F   P R O G R A M */
/* n.b.: when entering a state case, you have the option, by calling wwshow2(),
   of blanking out the TYPE window (and the menu of choices thereof)
*/
	while (state != FINISH_STATE) {
		switch (state) {
		case ORDER_STATE:
 			if ((result = get_phrase(&order)) > 0)
				state = ERROR_STATE;
			else switch (result) {
			case NEXT_SECTION:
				state = NUMBER_STATE;
				break;
			case PREVIOUS_SECTION:
				state = ACTION_STATE;
				break;
			case SAME_SECTION:
				state = ORDER_STATE;
				break;
			case DISPLAY:
				old_state = state;
				state = SEND_STATE;
				break;
			case SWITCH:
				state = SWITCH_STATE;
				break;
			case CLEAR:
				old_state = state;
				state = CLEAR_STATE;
				break;
			case CONSENT:
				old_state = state;
				state = CONSENT_STATE;
				break;
			case CALENDAR:
				old_state = state;
				state = CALENDAR_STATE;
				break;
			case SPECIAL:
				old_state = state;
				state = SPECIAL_STATE;
				break;
			case GENERAL:
				old_state = state;
				state = GENERAL_STATE;
				break;
			case MAINT_CONSENT:
				old_state = state;
				state = M_CONSENT_STATE;
				break;
			case MAINT_CALENDAR:
				old_state = state;
				state = M_CALENDAR_STATE;
				break;
			case MAINT_SPECIAL:
				old_state = state;
				state = M_SPECIAL_STATE;
				break;
			case MAINT_GENERAL:
				old_state = state;
				state = M_GENERAL_STATE;
				break;
			case EDITOR:
				old_state = state;
				state = ED_CMD_STATE;
				break;
			case LOCK:
				old_state = state;
				state = LOCK_STATE;
				break;
			}
			break;


		case NUMBER_STATE:
 			if ((result = get_phrase(&number)) > 0)
				state = ERROR_STATE;
			else switch (result) {
			case NEXT_SECTION:
				state = ACTION_STATE;
				break;
			case PREVIOUS_SECTION:
				state = ORDER_STATE;
				break;
			case SAME_SECTION:
				state = NUMBER_STATE;
				break;
			case DISPLAY:
				old_state = state;
				state = SEND_STATE;
				break;
			case SWITCH:
				state = SWITCH_STATE;
				break;
			case CLEAR:
				old_state = state;
				state = CLEAR_STATE;
				break;
			case CONSENT:
				old_state = state;
				state = CONSENT_STATE;
				break;
			case CALENDAR:
				old_state = state;
				state = CALENDAR_STATE;
				break;
			case SPECIAL:
				old_state = state;
				state = SPECIAL_STATE;
				break;
			case GENERAL:
				old_state = state;
				state = GENERAL_STATE;
				break;
			case MAINT_CONSENT:
				old_state = state;
				state = M_CONSENT_STATE;
				break;
			case MAINT_CALENDAR:
				old_state = state;
				state = M_CALENDAR_STATE;
				break;
			case MAINT_SPECIAL:
				old_state = state;
				state = M_SPECIAL_STATE;
				break;
			case MAINT_GENERAL:
				old_state = state;
				state = M_GENERAL_STATE;
				break;
			case EDITOR:
				old_state = state;
				state = ED_CMD_STATE;
				break;
			case LOCK:
				old_state = state;
				state = LOCK_STATE;
				break;
			}
			break;

		case ACTION_STATE:
 			if ((result = get_phrase(&action)) > 0)
				state = ERROR_STATE;
			else switch (result) {
			case NEXT_SECTION:
				state = ORDER_STATE;
				break;
			case PREVIOUS_SECTION:
				state = NUMBER_STATE;
				break;
			case SAME_SECTION:
				state = ACTION_STATE;
				break;
			case DISPLAY:
				old_state = state;
				state = SEND_STATE;
				break;
			case SWITCH:
				state = SWITCH_STATE;
				break;
			case CLEAR:
				old_state = state;
				state = CLEAR_STATE;
				break;
			case CONSENT:
				old_state = state;
				state = CONSENT_STATE;
				break;
			case CALENDAR:
				old_state = state;
				state = CALENDAR_STATE;
				break;
			case SPECIAL:
				old_state = state;
				state = SPECIAL_STATE;
				break;
			case GENERAL:
				old_state = state;
				state = GENERAL_STATE;
				break;
			case MAINT_CONSENT:
				old_state = state;
				state = M_CONSENT_STATE;
				break;
			case MAINT_CALENDAR:
				old_state = state;
				state = M_CALENDAR_STATE;
				break;
			case MAINT_SPECIAL:
				old_state = state;
				state = M_SPECIAL_STATE;
				break;
			case MAINT_GENERAL:
				old_state = state;
				state = M_GENERAL_STATE;
				break;
			case EDITOR:
				old_state = state;
				state = ED_CMD_STATE;
				break;
			case LOCK:
				old_state = state;
				state = LOCK_STATE;
				break;
			}
			break;

		case SEND_STATE:
			wwshow2();
			transmit_display();
			state = old_state;
	 		break;

		case CLEAR_STATE:
			wwshow2();
			clear_display();
			state = old_state;
	 		break;

		case SWITCH_STATE:
			if (err = switch_displays()) {
				state = ERROR_STATE;
				break;
			}

			state = ORDER_STATE;
			break;

		case CONSENT_STATE:
			if ((result = queue_select(&consent)) > 0) {
				state = ERROR_STATE;
				break;
			} else if (result == SELECTION) {
				state = ACTION_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case CALENDAR_STATE:
			if ((result = queue_select(&calendar)) > 0) {
				state = ERROR_STATE;
				break;
			} else if (result == SELECTION) {
				state = ACTION_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case SPECIAL_STATE:
			if ((result = queue_select(&special)) > 0) {
				state = ERROR_STATE;
				break;
			} else if (result == SELECTION) {
				state = ACTION_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case GENERAL_STATE:
			if ((result = queue_select(&general)) > 0) {
				state = ERROR_STATE;
				break;
			} else if (result == SELECTION) {
				state = ACTION_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case M_CONSENT_STATE:
			if (result = queue_maintain(&consent)) {
				state = ERROR_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case M_CALENDAR_STATE:
			if (result = queue_maintain(&calendar)) {
				state = ERROR_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case M_SPECIAL_STATE:
			if (result = queue_maintain(&special)) {
				state = ERROR_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case M_GENERAL_STATE:
			if (result = queue_maintain(&general)) {
				state = ERROR_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case ED_CMD_STATE:
			if (result = editor()) {
				state = ERROR_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case LOCK_STATE:
			if (result = lock_station()) {
				state = ERROR_STATE;
				break;
			} else {
				state = old_state;
				break;
			}

		case ERROR_STATE:
			wwshow2();
			printf("Error %d in main loop of program...\n", err);
			exit(1);
			break;

	 	default:
			state = ERROR_STATE;
			break;
		}

	}

	if (err = wwdelet1(ww_display[active_display])) {
		printf("Error %d in wwdelet1(ww_display)\n", err);
		exit(1);
	}

	wwshow2();
	exit(0);
}

int init_permanent()
{
	register loop;

/* Q U E U E   S E L E C T I O N   W I N D O W */
	/* allocate space for the window parms */
	ww_queue_select = (WINDOW *) calloc(1, sizeof(WINDOW));

	/* set window parameters */
	ww_queue_select->btype = 0;
	ww_queue_select->pbch = &bor2lin;
	ww_queue_select->pbstr = (BORDERSTR *) dummyadr;
	ww_queue_select->pfw = (FILEWW *) dummyadr;
	ww_queue_select->otr = TOP_CHOICE;
	ww_queue_select->obr = TOP_CHOICE + 4;
	ww_queue_select->olc = LEFT_CHOICE;
	ww_queue_select->orc = LEFT_CHOICE + 42;
	ww_queue_select->lm = 1;
	ww_queue_select->rm = 1;
	ww_queue_select->tm = 1;
	ww_queue_select->bm = 1;
	ww_queue_select->attr = NORMAL_VIDEO;
	ww_queue_select->wwctop = CURSOR_OFF;
	ww_queue_select->wwcbot = CURSOR_OFF;
	ww_queue_select->rdy = 0;
	ww_queue_select->ready = -1;
	ww_queue_select->index = -1;

	/* initialize window */
	if (err = wwinit(ww_queue_select))
 		return(err);

/* M E S S A G E   D I S P L A Y   W I N D O W S*/
	for (loop = 0; loop < 2; loop++) {
		/* allocate space for the window parms */
		ww_display[loop] = (WINDOW *) calloc(1, sizeof(WINDOW));

		/* set window parameters */
		ww_display[loop]->btype = 0;
		ww_display[loop]->pbch = &bor2lin;
		ww_display[loop]->pbstr = (BORDERSTR *) dummyadr;
		ww_display[loop]->pfw = (FILEWW *) dummyadr;
		ww_display[loop]->otr = TOP_DISPLAY;
		ww_display[loop]->obr = TOP_DISPLAY + 9;
		ww_display[loop]->olc = LEFT_DISPLAY;
		ww_display[loop]->orc = LEFT_DISPLAY + 17;
		ww_display[loop]->lm = 0;
		ww_display[loop]->rm = 0;
		ww_display[loop]->tm = 0;
		ww_display[loop]->bm = 0;
		ww_display[loop]->attr = NORMAL_VIDEO;
		ww_display[loop]->wwctop = CURSOR_OFF;
		ww_display[loop]->wwcbot = CURSOR_OFF;
		ww_display[loop]->rdy = 0;
		ww_display[loop]->ready = -1;
		ww_display[loop]->index = -1;

		/* initialize window */
		if (err = wwinit(ww_display[loop]))
 			return(err);

		/* put the page number in the footer */
		if (err = wwbfoot1(ww_display[loop], loop ? page2_footer : page1_footer, NORMAL_VIDEO))
			return(err);
	}

	/* activate active window */
	if (err = wwinsrt2(ww_display[active_display]))
 		return(err);

/* V O T E   L O C K   C O N T R O L   W I N D O W */
	/* allocate space for the window parms */
	ww_lock_control = (WINDOW *) calloc(1, sizeof(WINDOW));

	/* set window parameters */
	ww_lock_control->btype = 0;
	ww_lock_control->pbch = &bor2lin;
	ww_lock_control->pbstr = (BORDERSTR *) dummyadr;
	ww_lock_control->pfw = (FILEWW *) dummyadr;
	ww_lock_control->otr = TOP_CHOICE;
	ww_lock_control->obr = TOP_CHOICE + 7;
	ww_lock_control->olc = LEFT_CHOICE;
	ww_lock_control->orc = LEFT_CHOICE + 42;
	ww_lock_control->lm = 1;
	ww_lock_control->rm = 1;
	ww_lock_control->tm = 1;
	ww_lock_control->bm = 1;
	ww_lock_control->attr = NORMAL_VIDEO;
	ww_lock_control->wwctop = CURSOR_OFF;
	ww_lock_control->wwcbot = CURSOR_OFF;
	ww_lock_control->rdy = 0;
	ww_lock_control->ready = -1;
	ww_lock_control->index = -1;

	/* initialize window */
	if (err = wwinit(ww_lock_control))
 		return(err);

	/* write header and footer */
	if (err = wwbhead1(ww_lock_control, lock_header, REVERSE_VIDEO))
		return(err);

	if (err = wwbfoot1(ww_lock_control, lock_footer, REVERSE_VIDEO))
		return(err);

/* L O C K E D   S T A T I O N   L I S T   W I N D O W */
	/* allocate space for the window parms */
	ww_lock_list = (WINDOW *) calloc(1, sizeof(WINDOW));

	/* set window parameters */
	ww_lock_list->btype = 0;
	ww_lock_list->pbch = &bor2lin;
	ww_lock_list->pbstr = (BORDERSTR *) dummyadr;
	ww_lock_list->pfw = (FILEWW *) dummyadr;
	ww_lock_list->otr = TOP_DISPLAY;
	ww_lock_list->obr = TOP_DISPLAY + 23;
	ww_lock_list->olc = LEFT_DISPLAY - 1;
	ww_lock_list->orc = LEFT_DISPLAY + 23;
	ww_lock_list->lm = 1;
	ww_lock_list->rm = 1;
	ww_lock_list->tm = 1;
	ww_lock_list->bm = 1;
	ww_lock_list->attr = NORMAL_VIDEO;
	ww_lock_list->wwctop = CURSOR_OFF;
	ww_lock_list->wwcbot = CURSOR_OFF;
	ww_lock_list->rdy = 0;
	ww_lock_list->ready = -1;
	ww_lock_list->index = -1;

	/* initialize window */
	if (err = wwinit(ww_lock_list))
 		return(err);

	/* write header */
	if (err = wwbhead1(ww_lock_list, lock_list_header, REVERSE_VIDEO))
		return(err);


	return(OK);
}

int init_type(t)
TYPE *t;
{
	char buffer[BUFFER_LENGTH];
	int loop, count;

/* E X P E R I M E N T */
	cursize(CURSOR_OFF, CURSOR_OFF);

	/* count number of entries for type */
	for (count = 0; t->phrases[count].top; count++)
		;
	t->number_phrases = count;

	/* allocate window */
	t->ww = (WINDOW *) calloc(1, sizeof(WINDOW));

	/* set window parameters */
	t->ww->btype = 0;
	t->ww->pbch = &bor2lin;
	t->ww->pbstr = (BORDERSTR *) dummyadr;
	t->ww->pfw = (FILEWW *) dummyadr;
	t->ww->otr = TOP_CHOICE;
	t->ww->obr = TOP_CHOICE + t->number_phrases + 5;
	t->ww->olc = LEFT_CHOICE;
	t->ww->orc = LEFT_CHOICE + 42;
	t->ww->lm = 1;
	t->ww->rm = 1;
	t->ww->tm = 1;
	t->ww->bm = 1;
	t->ww->attr = NORMAL_VIDEO;
	t->ww->wwctop = CURSOR_OFF;
	t->ww->wwcbot = CURSOR_OFF;
	t->ww->rdy = 0;
	t->ww->ready = -1;
	t->ww->index = -1;

	/* initialize window */
	if (err = wwinit(t->ww))
 		return(err);

	/* build the window... this is done only once */
	/* first, put the type of phrase in the header */
	if (err = wwbhead1(t->ww, t->header, REVERSE_VIDEO))
		return(err);

	/* next, put the zero-will-blank info in the footer */
	if (err = wwbfoot1(t->ww, clear_area, REVERSE_VIDEO))
		return(err);

	/* now, number the choice lines and append the phrase itself */
	for (loop = 1; loop <= t->number_phrases; loop++) {
		if (err = wwputcur(loop + 1, 2 - (loop >= 10), t->ww))
			return(err);

		if (err = wwrite4(itoa(loop, buffer, 10), NORMAL_VIDEO, t->ww))
			return(err);

		if (err = wwputcur(loop + 1, 5, t->ww))
			return(err);

		if (t->phrases[loop - 1].bottom)
			sprintf(buffer, "%s %s", t->phrases[loop - 1].top, t->phrases[loop - 1].bottom);
		else
			strcpy(buffer, t->phrases[loop -1].top);
		if (err = wwrite4(buffer, NORMAL_VIDEO, t->ww))
			return(err);
	}

	return(OK);
}

int init_queue(q)
QUEUE *q;
{
	char buffer[BUFFER_LENGTH];
	int loop, count;

/* E X P E R I M E N T */
	cursize(CURSOR_OFF, CURSOR_OFF);

	/* allocate window */
	q->ww = (WINDOW *) calloc(1, sizeof(WINDOW));

	/* allocate queue entry pointers */
	q->entry = (char **) calloc(Q_ENTRIES, sizeof (char *));

	/* set window parameters */
	q->ww->btype = 0;
	q->ww->pbch = &bor2lin;
	q->ww->pbstr = (BORDERSTR *) dummyadr;
	q->ww->pfw = (FILEWW *) dummyadr;
	q->ww->otr = TOP_DISPLAY;
	q->ww->obr = TOP_DISPLAY + Q_PER_PAGE + 3;
	q->ww->olc = LEFT_DISPLAY - 1;
	q->ww->orc = LEFT_DISPLAY + 23;
	q->ww->lm = 1;
	q->ww->rm = 1;
	q->ww->tm = 1;
	q->ww->bm = 1;
	q->ww->attr = NORMAL_VIDEO;
	q->ww->wwctop = CURSOR_OFF;
	q->ww->wwcbot = CURSOR_OFF;
	q->ww->rdy = 0;
	q->ww->ready = -1;
	q->ww->index = -1;

	/* initialize window */
	if (err = wwinit(q->ww))
 		return(err);

	/* build the window */
	/* first, put the type of phrase in the header */
	sprintf(buffer, " %s ", q->order_of_business);
	if (err = wwbhead1(q->ww, buffer, REVERSE_VIDEO))
		return(err);

	/* then install the first page */
	if (err = queue_page(q))
		return(err);

	/* highlight the first entry */
	if (err = ww_attrsection(q->current_offset, 5, 1, strlen(null_q_entry), REVERSE_VIDEO, q->ww))
		return(err);

	return(OK);
}

int get_phrase(t)
TYPE *t;
{
	char buffer[BUFFER_LENGTH];
	int state = PHRASE_STATE;
	int value, selection, result, index;

	/* highlight area in message display window */
	if (wwputcur(t->start_row, 0, ww_display[active_display]))
		return(err);

	if (hilite2(ww_display[active_display], MD_WIDTH, 2, REVERSE_VIDEO))
		return(err);

	/* put up prompt for phrase selection */
	if (ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, t->ww))
		return(err);

	/* recover a visible prompt */
	getcsize();

	/* put it all up */
	if (err = wwinsrt2(t->ww))
		return(err);

	if (err = wwshow2())
		return(err);

	/* the next loop handles the numeric input */
	while(1) {
		if ((result = input_answer(t->ww, &value, state)) > 0)
			return(result);
		else switch (result) {
		case OK:
			if (state == PHRASE_STATE) {
				if ((!value || value > t->number_phrases)) {
					sprintf(buffer, error_format, value);
					if (err = ww_message(buffer, 0, 0, BOLD_VIDEO, t->ww))
						return(err);

					if (err = wwshow2())
						return(err);
					break;
				} else if (t == &number && value) {
					strcpy(buffer, t->phrases[value - 1].top);

					/* highlight files selection */
					if (err = ww_attrsection(value + 1, 5, 1, strlen(buffer), REVERSE_VIDEO, t->ww))
						return(err);

					if (err = ww_message(number_prompt, 0, 0, BOLD_VIDEO, t->ww))
						return(err);

					/* the contained kludge */
					/* at this point, I must eliminate the footer info regarding zero-will-blank */
					/* but wingnut Lepine makes that tough for me, so I will call a routine to contain the mess */
					if (err = footer_kludge(t->ww))
						return(err);

					if (err = wwshow2())
						return(err);

					selection = value;
					state = NUMBER_STATE;
					break;

				} else {  /* t = &order || t = &action */
					index = value ? value - 1 : t->number_phrases;	/* this accounts for selection 0: blank section */

					if (err = process_area(t, index))
						return(err);

					if (err = get_phrase_done(t))
						return(err);

					return(NEXT_SECTION);
					break;
				}

			} else {  /* state = NUMBER_STATE */
				itoa(value, buffer + strlen(buffer), 10);

				if (err = process_line(buffer, t->start_row, YES))
					return(err);

				if (err = process_line(t->phrases[selection - 1].bottom, t->start_row + 1, YES))
					return(err);

				if (err = get_phrase_done(t))
					return(err);

				/* unhighlight files selection */
				if (err = ww_attrsection(selection + 1, 5, 1, strlen(t->phrases[selection - 1]), NORMAL_VIDEO, t->ww))
					return(err);

				/* restore the zero-will-blank info in the footer */
				if (err = wwbfoot1(t->ww, clear_area, REVERSE_VIDEO))
					return(err);

				return(NEXT_SECTION);
				break;
 			}

		case INKEYX_UP:
			if (err = get_phrase_done(t))
				return(err);

			/* unhighlight files selection if previously highlighted (only happens in number */
			/* also rewrite the zero-will-blank footer*/
			if (state == NUMBER_STATE) {
				if (err = ww_attrsection(selection + 1, 5, 1, strlen(t->phrases[selection - 1]), NORMAL_VIDEO, t->ww))
					return(err);
				if (err = wwbfoot1(t->ww, clear_area, REVERSE_VIDEO))
					return(err);
			}

			return(PREVIOUS_SECTION);
			break;

		case INKEYX_DOWN:
			if (err = get_phrase_done(t))
				return(err);

			/* unhighlight files selection if previously highlighted (only happens in number */
			/* also rewrite the zero-will-blank footer*/
			if (state == NUMBER_STATE) {
				if (err = ww_attrsection(selection + 1, 5, 1, strlen(t->phrases[selection - 1]), NORMAL_VIDEO, t->ww))
					return(err);
				if (err = wwbfoot1(t->ww, clear_area, REVERSE_VIDEO))
					return(err);
			}

			return(NEXT_SECTION);
			break;

		case INKEYX_DEL:
	 		if (state == PHRASE_STATE) {

				/* replace footer for confirmation */
				if (err = footer_kludge(t->ww))
			 		return(err);
				if (err = wwbfoot1(t->ww, confirm_footer, REVERSE_VIDEO))
					return(err);


				/* highlight area in message display window */
				if (wwputcur(t->start_row, 0, ww_display[active_display]))
					return(err);

				if (hilite2(ww_display[active_display], MD_WIDTH, 2, REVERSE_VIDEO))
					return(err);

				/* write confirming message */
				if (err = ww_message(delete_confirm, 0, 0, BOLD_VIDEO, t->ww))
					return(err);


	 			if (err = wwshow2())
					return(err);

				state = DELETE_STATE;
				break;

			} else if (state == DELETE_STATE) {

				index = t->number_phrases;

				if (err = process_area(t, index))
					return(err);

				/* place the entry form of zero-footer in window */
				if (err = footer_kludge(t->ww))
 					return(err);
				if (err = wwbfoot1(t->ww, clear_area, REVERSE_VIDEO))
					return(err);

				/* highlight area in message display window */
				if (wwputcur(t->start_row, 0, ww_display[active_display]))
					return(err);

				if (hilite2(ww_display[active_display], MD_WIDTH, 2, REVERSE_VIDEO))
					return(err);

				/* get ready to do it again */
				if (err = ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, t->ww))
					return(err);

				if (err = wwshow2())
					return(err);

				state = PHRASE_STATE;
			}

			break;

		case INKEYX_ESCAPE:
			if (state == DELETE_STATE) {
				/* replace confirmation footer with delete footer */
				if (err = footer_kludge(t->ww))
			 		return(err);
				if (err = wwbfoot1(t->ww, clear_area, REVERSE_VIDEO))
					return(err);

				/* restore phrase prompt */
				if (err = ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, t->ww))
					return(err);

	 			if (err = wwshow2())
					return(err);

				state = PHRASE_STATE;
			}
			break;

		case INKEYX_F1:
			if (err = get_phrase_done(t))
				return(err);

			return(CONSENT);
			break;

		case INKEYX_F2:
			if (err = get_phrase_done(t))
				return(err);

			return(CALENDAR);
 			break;

		case INKEYX_F3:
			if (err = get_phrase_done(t))
				return(err);

			return(GENERAL);
			break;

		case INKEYX_F4:
			if (err = get_phrase_done(t))
				return(err);

			return(SPECIAL);
			break;

		case INKEYX_F6:
			if (err = get_phrase_done(t))
				return(err);

			return(EDITOR);
			break;

		case INKEYX_F7:
			if (err = get_phrase_done(t))
				return(err);

			return(SWITCH);
			break;

		case INKEYX_F8:
			if (err = get_phrase_done(t))
				return(err);

			return(LOCK);
			break;

		case INKEYX_F9:
			if (err = get_phrase_done(t))
				return(err);

			return(CLEAR);
 			break;

		case INKEYX_F10:
			if (err = get_phrase_done(t))
				return(err);

			return(DISPLAY);
			break;

		case INKEYX_CTRL_F1:
			if (err = get_phrase_done(t))
				return(err);

			return(MAINT_CONSENT);
			break;

		case INKEYX_CTRL_F2:
			if (err = get_phrase_done(t))
				return(err);

			return(MAINT_CALENDAR);
 			break;

		case INKEYX_CTRL_F3:
			if (err = get_phrase_done(t))
				return(err);

			return(MAINT_GENERAL);
			break;

		case INKEYX_CTRL_F4:
			if (err = get_phrase_done(t))
				return(err);

			return(MAINT_SPECIAL);
			break;

		default:
			break;
		}
	}
}


int get_phrase_done(t)
TYPE *t;
{
	cursize(CURSOR_OFF, CURSOR_OFF);

	if (err = wwputcur(t->start_row, 0, ww_display[active_display]))
		return(err);

	if (err = hilite2(ww_display[active_display], MD_WIDTH, 2, NORMAL_VIDEO))
		return(err);

	if (err = wwdelet1(t->ww))
		return(err);

	return(OK);
}


int process_area(t, index)
TYPE *t;
int index;
{

	if (err = process_line(t->phrases[index].top, t->start_row, YES))
		return(err);

	if (err = process_line(t->phrases[index].bottom, t->start_row + 1, YES))
		return(err);

}

int input_answer(ww, target, state)
WINDOW *ww;
int *target;
int state;
{
    int position = 0;			/* position marker for editing */
	int answer = NO;			/* default for yes/no questions */
	int keystroke, save;

	*target = 0;

	while (1) {
		if (grabkey(&keystroke, INKEY_NOECHO)) {

			if ((isalpha(keystroke) || (keystroke >= 0x20 && keystroke <= 0x5f)) && (state == ED_CMD_STATE)) {
				*target = keystroke;
 			return(MESSAGE_LEGAL);

			} else switch (keystroke) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				if (state != VERIFY_STATE && state != DELETE_STATE && state != ED_CMD_STATE) {
					if (position < MAX_DIGITS) {
						save = keystroke - '0';
						*target = (*target * 10) + save;
						wwrite1(keystroke, ww);
						wwcurrgt(1, ww);
						wwshow2();
 						position++;
					}
				}
				break;

			case 'Y':
			case 'y':
				if (state == VERIFY_STATE && position == 0) {
					answer = YES;
					wwrite1(keystroke, ww);
					wwcurrgt(1, ww);
					wwshow2();
					position++;
					break;
				} else
					break;

			case 'N':
			case 'n':
				if (state == VERIFY_STATE && position == 0) {
					answer = NO;
					wwrite1(keystroke, ww);
					wwcurrgt(1, ww);
					wwshow2();
					position++;
					break;
				} else
					break;

			case CR:
				if (state != DELETE_STATE) {
					if (state == VERIFY_STATE)
						return(answer);
					else if (position)
		 				return(OK);
					else
						return(INKEYX_DOWN);
				}
				break;

			case ESC:
				if (state != PHRASE_STATE)
					return(INKEYX_ESCAPE);
				break;

			case BS:
				if (position > 0) {
					if (state == VERIFY_STATE)
						answer = NO;
					else
						*target = (*target - save) / 10;

					wwcurlft(1, ww);
					wwrite1(SPACE, ww);
					wwshow2();
					position--;
				}
				break;

			default:
				break;
			}
		} else {
			switch (keystroke) {
			case KEY_F1:
				if (state == PHRASE_STATE || state == CONSENT_STATE)
					return(INKEYX_F1);
				break;

			case KEY_F2:
				if (state == PHRASE_STATE || state == CALENDAR_STATE)
					return(INKEYX_F2);
				break;

			case KEY_F3:
				if (state == PHRASE_STATE || state == GENERAL_STATE)
					return(INKEYX_F3);
				break;

			case KEY_F4:
				if (state == PHRASE_STATE || state == SPECIAL_STATE)
					return(INKEYX_F4);
				break;

			case KEY_F5:
				if (state == PHRASE_STATE)
					return(INKEYX_F5);
				break;

			case KEY_F6:
				if (state == PHRASE_STATE)
					return(INKEYX_F6);
				break;

			case KEY_F7:
				if (state == PHRASE_STATE)
					return(INKEYX_F7);
				break;

			case KEY_F8:
				if (state == PHRASE_STATE)
					return(INKEYX_F8);
				break;

			case KEY_F9:
				if (state == PHRASE_STATE || state == Q_MAINT_STATE)
					return(INKEYX_F9);
				break;

			case KEY_F10:
				if (state == PHRASE_STATE)
					return(INKEYX_F10);
				break;

			case KEY_UP_ARROW:
				if (state == PHRASE_STATE || state == Q_MAINT_STATE || state == ED_CMD_STATE)
					return(INKEYX_UP);
				break;

			case KEY_DOWN_ARROW:
				if (state == PHRASE_STATE || state == Q_MAINT_STATE || state == ED_CMD_STATE)
					return(INKEYX_DOWN);
				break;

			case KEY_PAGE_UP:
				if (state == Q_MAINT_STATE)
					return(INKEYX_PAGE_UP);
				break;

			case KEY_PAGE_DOWN:
				if (state == Q_MAINT_STATE)
					return(INKEYX_PAGE_DOWN);
				break;

			case KEY_HOME:
				if (state == Q_MAINT_STATE)
					return(INKEYX_HOME);
				break;

			case KEY_END:
				if (state == Q_MAINT_STATE)
					return(INKEYX_END);
				break;

			case KEY_CTRL_F1:
				if (state == PHRASE_STATE)
					return(INKEYX_CTRL_F1);
				break;

			case KEY_CTRL_F2:
				if (state == PHRASE_STATE)
					return(INKEYX_CTRL_F2);
				break;

			case KEY_CTRL_F3:
				if (state == PHRASE_STATE)
					return(INKEYX_CTRL_F3);
				break;

			case KEY_CTRL_F4:
				if (state == PHRASE_STATE)
					return(INKEYX_CTRL_F4);
				break;

			case KEY_DEL:
				if (state == Q_MAINT_STATE || state == PHRASE_STATE || state == ED_CMD_STATE || state == DELETE_STATE)
					return(INKEYX_DEL);
				break;

			case KEY_INS:
				if (state == ED_CMD_STATE)
					return(INKEYX_INS);
				break;

			default:
	 			break;
			}
		}
	}
}

int process_line(s, l, update)
char *s;
int l, update;
{
	register index;
	int offset;
	int md_dots_used = 0;
	char buffer[BUFFER_LENGTH];

	/* calculate number of spaces to indent line to be sent to message display */
	/* a side effect of the loop is to leave index = strlen(s) */
	for (index = 0; s[index]; index++)
		md_dots_used += md_char_width[s[index] - SPACE];
	display_offset[active_display][l].md = (MD_DOTS_PER_ROW - md_dots_used) / 6;

	/* create string to be sent to clerk's screen */
	offset = (MD_WIDTH - index) / 2;
	if (!s)
		*buffer = EOS;
	else {
		for (index = 0; index < offset; index++)
			buffer[index] = SPACE;
		strcpy(buffer + offset, s);
	}

	/* use offset to calculate the number of indent spaces for terminal displays */
	display_offset[active_display][l].td = offset + ((TD_WIDTH - MD_WIDTH) / 2);

	/* do all of the display stuff */
	/* first, clear the line in question */
	if (err = ww_message(" ", l, 0, NORMAL_VIDEO, ww_display[active_display]))
		return(err);

	/* then paint the new contents of the line */
	if (err = wwputcur(l, 0, ww_display[active_display]))
		return(err);

	if (err = wwrite3(buffer, ww_display[active_display]))
		return(err);

	if (err = wwshow2())
		return(err);

	/* now move the string into the appropriate virtual buffer */
	/* if the caller requested it */
	if (update == YES) {
		if (s)
			strcpy(virtual_display[active_display][l], s);
		else
			*virtual_display[active_display][l] = EOS;
	}

	return(OK);
}

int ww_attrsection(r, c, num_r, num_c, attr, ww)
unsigned short r, c, num_r, num_c, attr;
WINDOW *ww;
{

	if (err = wwputcur(r, c, ww))
		return(err);

	if (err = hilite2(ww, num_c, num_r, attr))
		return(err);

 return(OK);

}


int ww_message(s, r, c, attr, ww)
char *s;
unsigned short int r, c, attr;
WINDOW * ww;
{
	if (err = wwputcur(r, c, ww))
		return(err);

	/* blank out the line in question */
	do
		if (wwrite2(SPACE, NORMAL_VIDEO, ww))
			return(err);
	while ((err = wwcurrgt(1, ww)) != WWERR_BOUND);

	/* now go back and type the message */
	if (err = wwputcur(r, c, ww))
		return(err);

	if (err = wwrite4(s, attr, ww))
		return(err);

	/* I didn't think I needed this next line... */
	if (err = wwputcur(r, c + strlen(s), ww))
		return(err);

	return(OK);
}


int footer_kludge(ww)
WINDOW *ww;
{
	char buffer[81];
	int loop;

	/* fill the buffer with the footer character */
	for (loop = 0; loop < ww->wwlen - 2; loop++)
		buffer[loop] = ww->pbch->b;

	buffer[loop] = EOS;

	if (err = wwbfoot2(ww, buffer))
		return(err);

	return(OK);
	/* problems: this routine will not handle string borders nor will it correctly clear footers which traverse the border corners */
}


int header_kludge(ww)
WINDOW *ww;
{
	char buffer[81];
	int loop;

	/* fill the buffer with the header character */
	for (loop = 0; loop < ww->wwlen - 2; loop++)
		buffer[loop] = ww->pbch->t;

	buffer[loop] = EOS;

	if (err = wwbhead2(ww, buffer))
		return(err);

	return(OK);
	/* problems: this routine will not handle string borders nor will it correctly clear footers which traverse the border corners */
}


int switch_displays()
{
	register loop;

	if (err = wwdelet1(ww_display[active_display]))
		return(err);

	active_display = active_display == 1 ? 0 : 1;

	if (err = wwinsrt2(ww_display[active_display]))
		return(err);

	return(OK);
}

int transmit_display()
{
	register index;
	register limit;
	int layer;
	long loop;
	char *p;
	char buffer[BUFFER_LENGTH];


	/* if message semaphore is set to complete lock, forget it */
	if (mssg_sema == 2)
		return;

	/* printout buffering */
	for (loop = 0; loop < 3; loop++) {
		if (virtual_display[active_display][loop * 2])
			sprintf(printout_header[loop], "%s %s\n", virtual_display[active_display][loop * 2],
	 									virtual_display[active_display][(loop * 2) + 1]);
		else
			strcpy(printout_header[loop], "\n");
	}

/* M E S S A G E   D I S P L A Y */
	/* send clear character */
	if (mssg_sema == 1)
		clear_md_six();
	else
		if (com2_send(MD_CLEAR) == EOF)
			return;					/* we will want to communicate timeouts to the user... ma¤ana */

	/* take a respectful pause */
	for (loop = 0; loop < PAUSE_CYCLES; loop++)
		;

	/* push the contents of the buffer out */
	for (loop = 0; loop < 6 + (2 * (!mssg_sema)); loop++) {

	 	limit = display_offset[active_display][loop].md;
	 	p = virtual_display[active_display][loop];

 		if (*p) {
			for (index = 0; index < limit; index++)
				if (com2_send(SPACE) == EOF)
					return;

 			for (index = 0; p[index]; index++)
				if (com2_send(p[index]) == EOF)
					return;
		}

		if (com2_send(CR) == EOF)
				return;
    }

/* T E R M I N A L   D I S P L A Y */
	/* send clear character */
	if (mssg_sema == 1)
		clear_td_six();
	else
		if (prn_send(TD_CLEAR) == EOF)
			return;					/* we will want to communicate timeouts to the user... ma¤ana */

	/* get into position on the fifth display line */
	sprintf(buffer, td_cursor_address, 5 + SPACE - 1, SPACE);
	for (index = 0; buffer[index]; index++)
		if (prn_send(buffer[index]) == EOF)
			return;

	/* push the contents of the buffer out */
	/* we have to push each line out twice, once for upper section and once for lower section */
	for (loop = 0; loop < 6 + (2 * (!mssg_sema)); loop++) {

		for (layer = 0; layer < 2; layer++) {

			p = layer ? td_huge_bottom : td_huge_top;
			for (index = 0; p[index]; index++)
				if (prn_send(p[index]) == EOF)
					return;

		 	limit = display_offset[active_display][loop].td;
		 	p = virtual_display[active_display][loop];

			if (*p) {
				for (index = 0; index < limit; index++)
					if (prn_send(SPACE) == EOF)
						return;

 				for (index = 0; p[index]; index++)
					if (prn_send(p[index]) == EOF)
						return;
			}

			if (prn_send(CR) == EOF)
					return;

			if (prn_send('\n') == EOF)
					return;
		}
    }
}


int clear_display()
{

	/* if message semaphore is set to complete lock, forget it */
	if (mssg_sema == 2)
		return;

	/* else, if we are limited to first six lines... */
	if (mssg_sema == 1) {
		clear_md_six();
		clear_td_six();
		return;
	}

	else {
		if (prn_send(TD_CLEAR) 	== EOF)
			return;
		if (com2_send(MD_CLEAR) == EOF)
			return;
	}
}

int clear_md_six()
{
	int loop;

	for (loop = 0; loop < 6; loop++) {
		com2_send(MD_MOVE);
		com2_send(loop + '0');
	}

	com2_send(MD_MOVE);
	com2_send('0');
}

int clear_td_six()
{
	int loop, index;
	char buffer[BUFFER_LENGTH];

	/* get into position on the fifth display line */
	sprintf(buffer, td_cursor_address, 5 + SPACE - 1, SPACE);
	for (index = 0; buffer[index]; index++)
		if (prn_send(buffer[index]) == EOF)
			return;

	for (loop = 0; loop < 12; loop++) {
		if (prn_send(ESC) == EOF)
			return;

		if (prn_send('T') == EOF)
			return;

		if (prn_send(CR) == EOF)
			return;

		if (prn_send('\n') == EOF)
			return;
	}
}


int com1_send(c)	/* send a character to COM1: */
int c;
{
	int error = 0;
	error = sputc(vote_system, c);
	return((error < 0) ? EOF : OK);
}


int com2_send(c)	/* send a character to COM2: */
int c;
{
	int error = 0;
	error = sputc(mssg_display, c);
	return((error < 0) ? EOF : OK);
}

int prn_init()   /* set up the printer port */
{
	union REGS inreg, outreg;

	inreg.h.ah = 1;			/* function selection */
	inreg.x.dx = 0; 			/* PRN1: */
	int86(0x17, &inreg, &outreg); /* do it */
	return(OK);
}

int prn_send(c)	/* let ROM BIOS send a character to PRN1: */
int c;
{
	union REGS inreg, outreg;

	inreg.h.ah = 0;			/* function selection */
	inreg.h.al = c;			/* the character in question */
	inreg.x.dx = 0;			/* PRN2: */
	int86(0x17, &inreg, &outreg);	/* do it */
	return(outreg.h.ah & 0x01 ? EOF : OK);
}

int queue_page(q)
QUEUE *q;
{
	int loop;
	char buffer[BUFFER_LENGTH];
	int choice;

	/* turn cursor off */
	cursize(CURSOR_OFF, CURSOR_OFF);

	/* number the choice lines and append the phrase itself */
	for (loop = 1; loop <= Q_PER_PAGE; loop++) {
		choice = (q->current_page * Q_PER_PAGE) + loop;
		if (err = wwputcur(loop - 1, 0, q->ww))
			return(err);

		sprintf(buffer, choice >= 100 ? "%d" : choice >= 10 ? " %d" : "  %d", choice);

		if (err = wwrite4(buffer, NORMAL_VIDEO, q->ww))
			return(err);

		if (err = wwputcur(loop - 1, 5, q->ww))
			return(err);

		if (q->entry[choice - 1]) {
			if (err = ww_message(q->entry[choice - 1], loop - 1, 5, NORMAL_VIDEO, q->ww))
				return(err);
		} else {
			if (err = ww_message(null_q_entry, loop - 1, 5, NORMAL_VIDEO, q->ww))
				return(err);
		}
	}

	/* write "page... of..." footer */
	/* warning: if Q_MAX_PAGES > 9, call footer_kludge first */
	sprintf(buffer, queue_footer, q->current_page + 1, Q_MAX_PAGES);
	if (err = wwbfoot1(q->ww, buffer, REVERSE_VIDEO))
		return(err);

	/* turn cursor on */
	getcsize();

	return(OK);
}

int queue_maintain(q)
QUEUE *q;
{
	char buffer[BUFFER_LENGTH];
	char *p;
	int state = Q_MAINT_STATE;
	int attr_width;
	int value, selection, result, index;
	/* below for debugging only */
	int keystroke;

	/* determine the width of the queue line highlight */
	attr_width = strlen(null_q_entry);

	/* get rid of message display window */
	if (err = wwdelet1(ww_display[active_display]))
		return(err);

	/* we will replace it with the queue window */
	if (err = wwinsrt2(q->ww))
		return(err);

	/* put up prompt for phrase selection in files & resolutions window */
	if (err = ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, number.ww))
		return(err);

	/* place the entry form of zero-footer in f&r window */
	if (err = footer_kludge(number.ww))
 		return(err);
	if (err = wwbfoot1(number.ww, clear_entry, REVERSE_VIDEO, number.ww))
		return(err);

	/* recover a visible prompt */
	getcsize();

	/* activate window for files & resolutions */
	if (err = wwinsrt2(number.ww))
		return(err);

	if (err = wwshow2())
		return(err);

	/* the next loop handles the numeric input */
	while(1) {
		if ((result = input_answer(number.ww, &value, state)) > 0)
			return(result);
		else switch (result) {
		case OK:
			if (state == Q_MAINT_STATE) {
				if ((!value || value > number.number_phrases)) {
					sprintf(buffer, error_format, value);
					if (err = ww_message(buffer, 0, 0, BOLD_VIDEO, number.ww))
						return(err);

					if (err = wwshow2())
						return(err);
					break;
				} else {
					strcpy(buffer, number.phrases[value - 1].top);

					/* highlight files selection */
					if (err = ww_attrsection(value + 1, 5, 1, strlen(buffer), REVERSE_VIDEO, number.ww))
						return(err);

					if (err = ww_message(number_prompt, 0, 0, BOLD_VIDEO, number.ww))
						return(err);

					/* clear footer */
					if (err = footer_kludge(number.ww))
						return(err);

					if (err = wwshow2())
						return(err);

					selection = value;
					state = NUMBER_STATE;
					break;

				}


			} else {  /* state = NUMBER_STATE */
				itoa(value, buffer + strlen(buffer), 10);

				/* put completed selection in memory */
	 			/* first, free up anything that may have been there */
				if (p = q->entry[(q->current_page * Q_PER_PAGE) + q->current_offset])
					free(p);
				/* then copy the information */
				strcpy(p = q->entry[(q->current_page * Q_PER_PAGE) + q->current_offset] =  malloc(strlen(buffer) + 1), buffer);

				/* now, take care of the queue list window */
				/* display the new selection */
				if (err = ww_message(p, q->current_offset, 5, NORMAL_VIDEO, q->ww))
					return(err);

				/* compare this segment of code to that for INKEYX_DOWN */
				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, NORMAL_VIDEO, q->ww))
					return(err);

	 			/* either we are not at bottom of page, or we are */
				if (q->current_offset < Q_PER_PAGE - 1)
					q->current_offset++;
 				else {
					/* we change pages if we can (not on last page) */
					if (q->current_page < Q_MAX_PAGES - 1) {
						q->current_page++;

						/* set the offset to the top line of the page */
						q->current_offset = 0;

						if (err = queue_page(q))
 							return(err);
					}
				}

				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, REVERSE_VIDEO, q->ww))
					return(err);

				/* unhighlight files selection */
				if (err = ww_attrsection(selection + 1, 5, 1, strlen(number.phrases[selection - 1]), NORMAL_VIDEO, number.ww))
					return(err);

				/* restore the zero-will-blank info in the footer */
				if (err = wwbfoot1(number.ww, clear_entry, REVERSE_VIDEO))
					return(err);

				/* get ready to do it again */
				if (err = ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, number.ww))
					return(err);

				if (err = wwshow2())
					return(err);

				state = Q_MAINT_STATE;
				break;
 			}

		case INKEYX_UP:
			/* we always unhighlight the current line */
			if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, NORMAL_VIDEO, q->ww))
				return(err);

 			/* either we are not at top of page, or we are */
			if (q->current_offset)
				q->current_offset--;
 			else {
				/* we change pages if we can (not on page 0) */
				if (q->current_page) {
					q->current_page--;

					/* set the offset to the bottom line of the page */
					q->current_offset = Q_PER_PAGE - 1;

					if (err = queue_page(q))
 						return(err);
				}
			}

			if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, REVERSE_VIDEO, q->ww))
				return(err);

			if (err = wwshow2())
				return(err);
			break;

		case INKEYX_DOWN:
			/* we always unhighlight the current line */
			if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, NORMAL_VIDEO, q->ww))
				return(err);

 			/* either we are not at bottom of page, or we are */
			if (q->current_offset < Q_PER_PAGE - 1)
				q->current_offset++;
 			else {
				/* we change pages if we can (not on last page) */
				if (q->current_page < Q_MAX_PAGES - 1) {
					q->current_page++;

					/* set the offset to the top line of the page */
					q->current_offset = 0;

					if (err = queue_page(q))
 						return(err);
				}
			}

			if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, REVERSE_VIDEO, q->ww))
				return(err);

			if (err = wwshow2())
				return(err);
			break;

		case INKEYX_PAGE_UP:
			/* we change pages if we can (not on page 0) */
			if (q->current_page) {

				/* always unhighlight the current line */
				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, NORMAL_VIDEO, q->ww))
					return(err);

				q->current_page--;

				/* set the offset to the bottom line of the page */
				q->current_offset = 0;

				if (err = queue_page(q))
						return(err);
				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, REVERSE_VIDEO, q->ww))
					return(err);
				}

			if (err = wwshow2())
				return(err);
			break;

		case INKEYX_PAGE_DOWN:
			/* we change pages if we can (not on last page) */
			if (q->current_page < Q_MAX_PAGES - 1) {

				/* unhighlight the current line */
				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, NORMAL_VIDEO, q->ww))
					return(err);

				q->current_page++;

				/* set the offset to the top line of the page */
				q->current_offset = 0;

				if (err = queue_page(q))
					return(err);
				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, REVERSE_VIDEO, q->ww))
					return(err);
			}

			if (err = wwshow2())
				return(err);
			break;

		case INKEYX_DEL:
	 		if (state == Q_MAINT_STATE) {

				/* replace footer for confirmation */
				if (err = footer_kludge(number.ww))
			 		return(err);
				if (err = wwbfoot1(number.ww, confirm_footer, REVERSE_VIDEO, number.ww))
					return(err);


				/* write confirming message */
				if (err = ww_message(delete_confirm, 0, 0, BOLD_VIDEO, number.ww))
					return(err);

	 			if (err = wwshow2())
					return(err);

				state = DELETE_STATE;
				break;

			} else if (state == DELETE_STATE) {
				/* first, free up anything that may have been there */
				if (p = q->entry[(q->current_page * Q_PER_PAGE) + q->current_offset])
					free(p);

 				/* now make that entry NULL */
				q->entry[(q->current_page * Q_PER_PAGE) + q->current_offset] = NULL;

				/* now, take care of the queue list window */
				/* display the null queue selection */
				if (err = ww_message(null_q_entry, q->current_offset, 5, NORMAL_VIDEO, q->ww))
					return(err);

				/* place the entry form of zero-footer in f&r window */
				if (err = footer_kludge(number.ww))
 					return(err);
				if (err = wwbfoot1(number.ww, clear_entry, REVERSE_VIDEO, number.ww))
					return(err);

				if (err = ww_attrsection(q->current_offset, 5, 1, attr_width, REVERSE_VIDEO, q->ww))
					return(err);

				/* get ready to do it again */
				if (err = ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, number.ww))
					return(err);

				if (err = wwshow2())
					return(err);

				state = Q_MAINT_STATE;
			}

			break;

		case INKEYX_ESCAPE:
 		if (state == Q_MAINT_STATE) {
				/* expunge queue window */
				if (err = wwdelet1(q->ww))
					return(err);

				/* zot window for files & resolutions */
				if (err = wwdelet1(number.ww))
					return(err);

				/* replace the area form of zero-footer in f&r window */
				if (err = footer_kludge(number.ww))
 					return(err);
				if (err = wwbfoot1(number.ww, clear_area, REVERSE_VIDEO, number.ww))
					return(err);

				/* restore message display window to grace */
				if (err = wwinsrt2(ww_display[active_display]))
					return(err);

				return(OK);

			} else if (state == DELETE_STATE) {
				/* replace confirmation footer with delete footer */
				if (err = footer_kludge(number.ww))
			 		return(err);
				if (err = wwbfoot1(number.ww, clear_entry, REVERSE_VIDEO, number.ww))
					return(err);

				/* restore phrase prompt */
				if (err = ww_message(phrase_prompt, 0, 0, BOLD_VIDEO, number.ww))
					return(err);

	 			if (err = wwshow2())
					return(err);

				state = Q_MAINT_STATE;
			}

			break;

		default:
			break;
		}
	}
}


queue_select(q)
QUEUE *q;
{
	char buffer[BUFFER_LENGTH];
	char *p;
	int state;
	int value, selection, result, index;

	 /* bring up selection header */
	if (err = header_kludge(ww_queue_select))
		return(err);

	sprintf(buffer, " %s ", q->order_of_business);
	if (err = wwbhead1(ww_queue_select, buffer, REVERSE_VIDEO))
		return(err);

	/* footer: next selection if there is one or canned message if there is not */
	if (err = footer_kludge(ww_queue_select))
		return(err);

	sprintf(buffer,(q->next_item < Q_ENTRIES && q->entry[q->next_item - 1]) ? next_in_queue : no_next_in_queue,q->entry[q->next_item - 1]);
	if (err = wwbfoot1(ww_queue_select, buffer, REVERSE_VIDEO))
		return(err);

	/* prompt the user for input */
	if (err = ww_message(calendar_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
		return(err);

	if (err = wwinsrt2(ww_queue_select))
		return(err);

	if (err = wwshow2())
		return(err);

	/* selection loop */

	/* first, set up state to pass to input answer: this value will allow us to trap appropriate use of "next item" key */
	if (q == &consent)
		state = CONSENT_STATE;
	else if (q == &calendar)
		state = CALENDAR_STATE;
	else if (q == &general)
		state = GENERAL_STATE;
	else if (q == &special)
		state = SPECIAL_STATE;

	/* the next loop handles the numeric input */
	while(1) {
		if ((result = input_answer(ww_queue_select, &value, state)) > 0)
			return(result);
		else switch (result) {
		case OK:
			if ((result = queue_to_screen(q, value)) < 0)
				break;
			else if (result > 0) {
				return(result);
				break;
			} else {
				return(SELECTION);
				break;
			}

		case INKEYX_F1:
		case INKEYX_F2:
		case INKEYX_F3:
		case INKEYX_F4:
 			/* set value to next entry */
			value = q->next_item;

			/* and off we go!!! */
			if ((result = queue_to_screen(q, value)) < 0)
				break;
			else if (result > 0) {
				return(result);
				break;
			} else {
				return(SELECTION);
				break;
			}

		case INKEYX_DOWN:
	 	default:
			/* deactivate the queue selection window */
			if (err = wwdelet1(ww_queue_select))
				return(err);

			return(NO_SELECTION);
			break;

		}
	}
}


int queue_to_screen(q, value)
QUEUE *q;
int value;
{
	char buffer[BUFFER_LENGTH];
	int index;

	if (value < 1 || value > Q_ENTRIES) {
		sprintf(buffer, error_format, value);
		if (err = ww_message(buffer, 0, 0, BOLD_VIDEO, ww_queue_select))
			return(err);

		if (err = wwshow2())
			return(err);

		return(-1);		/* indicate recoverable error... */
	} else if (!q->entry[value - 1]) {
		sprintf(buffer, blank_entry, value);
		if (err = ww_message(buffer, 0, 0, BOLD_VIDEO, ww_queue_select))
			return(err);

		if (err = wwshow2())
			return(err);

		return(-1);		/* he who fights and runs away... */
	} else {
		/* everything fine on input, so update the active display */
		if (err = process_line(q->order_of_business, 0, YES))
			return(err);
		if (err = process_line(q->entry[value - 1], 2, YES))
			return(err);

		/* now blank out all the other lines in the active display */
		if (err = process_line(NULL, 1, YES))
			return(err);

		for (index = 3; index < 6; index++)
			if (err = process_line(NULL, index, YES))
			return(err);

		/* deactivate the queue selection window */
		if (err = wwdelet1(ww_queue_select))
			return(err);
	}

	q->next_item = value + 1;
	return(OK);
}

editor()
{
	char mssg_buffer[MAX_MESSAGE + 1];
	char buffer[BUFFER_LENGTH];
	char *p;
	int state = ED_CMD_STATE;
	int value, selection, result, index;
	int current_line = 0;
	int position = 0;
	int keystroke;

	 /* bring up selection header */
	if (err = header_kludge(ww_queue_select))
		return(err);

	if (err = wwbhead1(ww_queue_select, editor_header, REVERSE_VIDEO))
		return(err);

	/* footer: basic information on how to enter/delete line*/
	if (err = footer_kludge(ww_queue_select))
		return(err);

	if (err = wwbfoot1(ww_queue_select, editor_footer, REVERSE_VIDEO))
		return(err);

	/* highlight the current line */
		if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
			return(err);

	/* prompt the user for input */
	if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
		return(err);

	if (err = wwinsrt2(ww_queue_select))
		return(err);

	if (err = wwshow2())
		return(err);

	/* selection loop */

	while(1) {
		if ((result = input_answer(ww_queue_select, &keystroke, state)) > 0)
			return(result);
	 	else if (result == MESSAGE_LEGAL) {
			/* process the one character */
			keystroke = (keystroke >= 0x61) && (keystroke <= 0x7a) ? keystroke ^ 0x20 : keystroke;
			mssg_buffer[position] = keystroke;
			wwrite1(keystroke, ww_queue_select);
			wwcurrgt(1, ww_queue_select);
			wwshow2();
			position++;

			result = INKEYX_INS;
		}

		switch (result) {

		case INKEYX_DOWN:
			/* clear existing highlight */
			if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, NORMAL_VIDEO, ww_display[active_display]))
				return(err);

			/* increment (with wrap) active line & highlight */
			current_line = (current_line == 7) ? 0 : current_line + 1;
			if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
				return(err);

			if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
				return(err);

 			if (err = wwshow2())
				return(err);

			break;

		case INKEYX_UP:
			/* clear existing highlight */
			if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, NORMAL_VIDEO, ww_display[active_display]))
				return(err);

			/* decrement (with wrap) active line & highlight */
			current_line = (current_line > 0) ? current_line - 1 : 7;
			if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
				return(err);

			if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
				return(err);

 			if (err = wwshow2())
				return(err);

			break;

		case INKEYX_INS:
			state = ED_INP_STATE;

			/* edit input footer */
			if (err = footer_kludge(ww_queue_select))
				return(err);

			if (err = wwbfoot1(ww_queue_select, ed_inp_footer, REVERSE_VIDEO))
				return(err);

 			if (err = wwshow2())
				return(err);

			/* input loop */
			while (state != ED_CMD_STATE) {
				if (grabkey(&keystroke, INKEY_NOECHO)) {
				if (isalpha(keystroke) || (keystroke >= 0x20 && keystroke <= 0x5f)) {
					if (position < MAX_MESSAGE) {
						keystroke = (keystroke >= 0x61) && (keystroke <= 0x7a) ? keystroke ^ 0x20 : keystroke;
						mssg_buffer[position] = keystroke;
						wwrite1(keystroke, ww_queue_select);
						wwcurrgt(1, ww_queue_select);
						wwshow2();
						position++;
					}

				} else switch (keystroke) {
					case CR:
						if (position > 0) {
							/* EOS */
							mssg_buffer[position] = EOS;

							/* process line */
							if (err = process_line(mssg_buffer, current_line, YES))
								return(err);
						}

						/* do cleanup */
						/* footer: basic information on how to enter/delete line*/
						if (err = footer_kludge(ww_queue_select))
							return(err);

						if (err = wwbfoot1(ww_queue_select, editor_footer, REVERSE_VIDEO))
							return(err);

						/* restore default prompt */
						if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
							return(err);

						/* clear existing highlight */
						if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, NORMAL_VIDEO, ww_display[active_display]))
							return(err);

						/* increment (with wrap) active line & highlight */
						current_line = (current_line == 7) ? 0 : current_line + 1;
						if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
							return(err);

			 			if (err = wwshow2())
							return(err);

						state = ED_CMD_STATE;
						position = 0;
						break;

					case ESC:
						/* reset position and zero internal buffer */
 						position = 0;
						mssg_buffer[0] = EOS;

						/* footer: basic information on how to enter/delete line*/
						if (err = footer_kludge(ww_queue_select))
							return(err);

						if (err = wwbfoot1(ww_queue_select, editor_footer, REVERSE_VIDEO))
							return(err);

						if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
							return(err);

						/* get ready to do it again */
						if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
							return(err);

						if (err = wwshow2())
							return(err);

						state = ED_CMD_STATE;
						break;

					case BS:
						if (position > 0) {
                                  mssg_buffer[position] = EOS;
							wwcurlft(1, ww_queue_select);
							wwrite1(SPACE, ww_queue_select);
							wwshow2();
							position--;
						}
						break;
				}
				}
              }
			break;

		case INKEYX_DEL:
			if (state == ED_CMD_STATE) {
				/* replace footer for confirmation */
				if (err = footer_kludge(ww_queue_select))
			 		return(err);
				if (err = wwbfoot1(ww_queue_select, confirm_footer, REVERSE_VIDEO))
					return(err);

				/* write confirming message */
				if (err = ww_message(delete_confirm, 0, 0, BOLD_VIDEO, ww_queue_select))
					return(err);

	 			if (err = wwshow2())
					return(err);

				state = DELETE_STATE;
				break;

	 		} else if (state == DELETE_STATE) {
				/* process_line */

				if (err = process_line(NULL, current_line, YES))
					return(err);

				/* footer: basic information on how to enter/delete line*/
				if (err = footer_kludge(ww_queue_select))
					return(err);

				if (err = wwbfoot1(ww_queue_select, editor_footer, REVERSE_VIDEO))
					return(err);

				if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
					return(err);

				/* get ready to do it again */
				if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
					return(err);

				if (err = wwshow2())
					return(err);

				state = ED_CMD_STATE;
			}
			break;

		case INKEYX_ESCAPE:

			if (state == ED_CMD_STATE) {

			/* unhighlight message display line */
			if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, NORMAL_VIDEO, ww_display[active_display]))
				return(err);


			/* deactivate the queue selection window */
				if (err = wwdelet1(ww_queue_select))
					return(err);

				return(OK);
				break;

			} else if (state == DELETE_STATE) {
				/* footer: basic information on how to enter/delete line*/
				if (err = footer_kludge(ww_queue_select))
					return(err);

				if (err = wwbfoot1(ww_queue_select, editor_footer, REVERSE_VIDEO))
					return(err);

				if (err = ww_attrsection(current_line, 0, 1, MAX_MESSAGE, REVERSE_VIDEO, ww_display[active_display]))
					return(err);

				/* get ready to do it again */
				if (err = ww_message(editor_prompt, 0, 0, BOLD_VIDEO, ww_queue_select))
					return(err);

				if (err = wwshow2())
					return(err);

				state = ED_CMD_STATE;
				break;
			}

		}
	}
}



int grabkey(target, echoflag)
int *target;
int echoflag;
{
	int result = 1;

	do
		result = (echoflag == INKEY_ECHO) ? (*target = qgetc()) && result : (*target = qgetch()) && result;
	while (!(*target));

	return(result);
}

/***************************************************************
	Idle Function

	Calls kbget() to move characters from DOS to the keyboard
	queue. If a Ctrl Break or Ctrl C is detected, does an
	orderly exit.

**************************************************************/

idle()

	{
   while (1)
   	{
      kbget();
      if ( abortchk() )
      	{
         printf("quitting\n");
		sclose(mssg_display);
 	sclose(vote_system);
         exit(0);
         }
      pause();               /* give someone else a chance */
      }
	}


vs_rx()
{
	int index;
	int limit;
	int layer, n, offset;
	int dots_used = 0;
	int yes_length, no_length;
	long loop;
	char *p;
	int yes_total, no_total;
	char buffer[BUFFER_LENGTH];
	char no_space_buffer[2][10], yes_space_buffer[2][10], number_buffer[10];

	while (1) {
		switch (n = sgetc(vote_system)) {
		case VS_MD_VOTE_OPEN:
			clear_results();
			mssg_sema = 0;
			break;

		case VS_MD_VOTE_CLOSED:
	 		mssg_sema = 1;
			tx_locks();
 	 		break;

			tx_header();

		case VS_MD_RESULTS:
			/* first, close any other access to the message display board */
			mssg_sema = 2;

			/* the numeric results follow */
			yes_total = sgetc(vote_system);
			no_total = sgetc(vote_system);

			/* send header information back to the voting subsystem */
			tx_header();

			/* now the fun part */
			/* first, delay the output ~5 seconds */
			delay(70);

			/* first do the yeas/nays line */
			if (!result_offset[0].md)				/* if we have not already done so */
				process_result(yeas_nays, 0);			/* process the centering information for "YEAS      NAYS" */

 			/* then push the result out to md & terminals */
			result_md(0);
			result_td(0);


			/* now, deal with the bottom line (numbers) */
			dots_used = 0;
			itoa(yes_total, number_buffer, 10);

			/* determine dots in buffer */
			for (index = 0; number_buffer[index]; index++)
				dots_used += md_char_width[number_buffer[index] - SPACE];

			/* assign index (length of number string) to variable to use when we do terminal display */
			yes_length = index;

			/* "YEAS" is 6*4 = 24 dots wide, and we want to center the numbers underneath */
			/* so we divide by 6 (2 halves * 3 dots per space on the md) */
			offset = (24 - dots_used) / 6;

			for (index = 0; index < offset; index++)
				yes_space_buffer[0][index] = SPACE;
			yes_space_buffer[0][index] = EOS;


			/* then do the nays line */
			dots_used = 0;
			itoa(no_total, number_buffer, 10);

			/* determine dots in buffer */
			for (index = 0; number_buffer[index]; index++)
				dots_used += md_char_width[number_buffer[index] - SPACE];

			/* assign index (length of number string) to variable to use when we do terminal display */
			no_length = index;

			/* "NAYS" is 6*4 = 24 dots wide, and we want to center the numbers underneath */
			/* so we divide by 6 (2 halves * 3 dots per space on the md) */
			offset = (24 - dots_used) / 6;

			for (index = 0; index < offset; index++)
				no_space_buffer[0][index] = SPACE;
			no_space_buffer[0][index] = EOS;

			sprintf(buffer, "%s%d%s      %s%d", yes_space_buffer[0], yes_total, yes_space_buffer[0], no_space_buffer[0], no_total);
			process_result(buffer, 1);

			/* and off we go to the message display */
			result_md(1);


			/* now we do the building of the terminal display line */
 			/* we already know how many digits are in each of the two numbers */
			/* we want to get each of them roughly centered under the appropriate title */
			/* at this point, I am going to take a rather brute-force approach */
			switch (yes_length) {
			case 1:
				strcpy(yes_space_buffer[0], "  ");
				strcpy(yes_space_buffer[1], " ");
				break;

			case 2:
				strcpy(yes_space_buffer[0], " ");
				strcpy(yes_space_buffer[1], " ");
				break;

			case 3:
				strcpy(yes_space_buffer[0], " ");
				strcpy(yes_space_buffer[1], "");
				break;
			}

			switch (no_length) {
			case 1:
				strcpy(no_space_buffer[0], "  ");
				break;

			case 2:
				strcpy(no_space_buffer[0], " ");
				break;

			case 3:
				strcpy(no_space_buffer[0], " ");
				break;
			}

			sprintf(buffer, "%s%d%s      %s%d", yes_space_buffer[0], yes_total, yes_space_buffer[1], no_space_buffer[0], no_total);
			process_result(buffer, 1);

			/* and off we go to the terminal display */
			result_td(1);

			/* restore semaphore to allow access to first six lines */
			mssg_sema = 1;

			break;
		}
	}
}


int result_md(l)
int l;
{
	register index;
	register limit;
	int display_row;
	int layer;
	long loop;
	char *p;


/* M E S S A G E   D I S P L A Y */

	/* position ourselves at the correct line */
	display_row = l + 6;
	if (com2_send(MD_MOVE) == EOF)
		return;
	if (com2_send(display_row + '0') == EOF)
		return;

	/* now send the line to the message display board */
 	p = virtual_result[l];
	if (*p) {
		for (index = 0; index < result_offset[l].md; index++)
			if (com2_send(SPACE) == EOF)
				return;

		for (index = 0; p[index]; index++)
			if (com2_send(p[index]) == EOF)
				return;
		}

	if (com2_send(CR) == EOF)
		return;
}

int result_td(l)
int l;
{
	register index;
	register limit;
	int display_row;
	int layer;
	long loop;
	char *p;
	char buffer[BUFFER_LENGTH];


/* T E R M I N A L   D I S P L A Y */

	/* get into position on the correct display line */
	/* first, compute which line that is */
	display_row = 17 + (2 * l);			/* line 17 or 19 */

	/* now, go to first column of that line */
	sprintf(buffer, td_cursor_address, display_row + SPACE - 1, SPACE);
		for (index = 0; buffer[index]; index++)
			if (prn_send(buffer[index]) == EOF)
				return;

	/* we have to push the line out twice, once for upper section and once for lower section */
	for (layer = 0; layer < 2; layer++) {

		p = layer ? td_huge_bottom : td_huge_top;
		for (index = 0; p[index]; index++)
			if (prn_send(p[index]) == EOF)
				return;

	 	p = virtual_result[l];

		if (*p) {
			for (index = 0; index < result_offset[l].td; index++)
				if (prn_send(SPACE) == EOF)
					return;

			for (index = 0; p[index]; index++)
				if (prn_send(p[index]) == EOF)
					return;
		}

		if (prn_send(CR) == EOF)
				return;

		if (prn_send('\n') == EOF)
				return;
	}
}

int process_result(s, l)
char *s;
int l;
{
	register index;
	int offset;
	int md_dots_used = 0;
	char buffer[BUFFER_LENGTH];

	/* calculate number of spaces to indent line to be sent to message display */
	/* a side effect of the loop is to leave index = strlen(s) */
	for (index = 0; s[index]; index++)
		md_dots_used += md_char_width[s[index] - SPACE];
	result_offset[l].md = (MD_DOTS_PER_ROW - md_dots_used) / 6;


	/* calculate the number of indent spaces for terminal displays */
	result_offset[l].td = (TD_WIDTH - index) / 2;


	/* now move the string into the appropriate virtual buffer */
	if (s)
		strcpy(virtual_result[l], s);
	else
		*virtual_result[l] = EOS;

	return(OK);
}

clear_results()
{
	int loop, index, display_row;
	char buffer[BUFFER_LENGTH];

	/* first, take care of messgage display lines 7 & 8 */
	for (loop = 0; loop < 2; loop++) {
		/* position ourselves at the correct line */
		display_row = loop + 6;
		if (com2_send(MD_MOVE) == EOF)
			return;
		if (com2_send(display_row + '0') == EOF)
			return;
	}

	/* then, in preparation of erasing bottom terminal lines, get to line 17 */
	sprintf(buffer, td_cursor_address, 17 + SPACE - 1, SPACE);
	for (index = 0; buffer[index]; index++)
		if (prn_send(buffer[index]) == EOF)
			return;

	/* and get rid of the next four lines */
	for (loop = 0; loop < 4; loop++) {
		if (prn_send(ESC) == EOF)
			return;

		if (prn_send('T') == EOF)
			return;

		if (prn_send(CR) == EOF)
			return;

		if (prn_send('\n') == EOF)
			return;
	}
}

tx_header()
{
	int loop;

	for (loop = 0; loop < 3; loop++)
		sputs(vote_system, printout_header[loop]);
}


tx_locks()
{
	int loop;

	for (loop = 0; loop < 134; loop++)
		if (member[loop].vote == STATION_LOCKED)
			sputc(vote_system, member[loop].seat);

	sputc(vote_system, VS_MD_LOCKS_DONE);
}
int lock_station()
{
	int crummy, result;
	int elements = 133;
	char buffer[BUFFER_LENGTH];
	LEX *current_lex = member;
	LEX key_structure, *resulting_lex;

	int compare_lex();

	/* get rid of message display window */
	if (err = wwdelet1(ww_display[active_display]))
		return(err);

	/* replace it with the lock list window */
	if (err = wwinsrt2(ww_lock_list))
		return(err);

	/* put up the control window */
	if (err = wwinsrt2(ww_lock_control))
		return(err);

	/* display first legislator in control window */
	if (err = show_current_lex(current_lex))
		return(err);

/* M A I N   L O O P */

	/* reset state */
	crummy = 0;

	do {
 		sprintf(buffer, crummy ? no_name_match : "", key_structure.name);
		if (err = ww_message(buffer, 0, 0, BOLD_VIDEO, ww_lock_control))
			return(err);

		if (err = ww_message(lock_name_prompt, 1, 0, BOLD_VIDEO, ww_lock_control))
			return(err);

 		if (err = wwshow2())
			return(err);

		crummy = 0;

		/* get a visible cursor */
		getcsize();

		result = get_name(key_structure.name);

		/* zot the cursor */
		cursize(CURSOR_OFF, CURSOR_OFF);

		switch (result) {

		case '+':
			if (current_lex->vote == STATION_LOCKED) {
				lock_total--;
				current_lex->vote = STATION_UNLOCKED;
				if (err = paint_lock_list())
					return(err);
			}
			break;

		case '-':
			if (current_lex->vote == STATION_UNLOCKED) {
				lock_total++;
				current_lex->vote = STATION_LOCKED;
				if (err = paint_lock_list())
					return(err);
			}
			break;


		case ESC:
			/* expunge the two lock windows */
			if (err = wwdelet1(ww_lock_control))
				return(err);

			if (err = wwdelet1(ww_lock_list))
				return(err);

			/* reignite the current message display */
			if (err = wwinsrt2(ww_display[active_display]))
				return(err);

			return(OK);
			break;

		case KEY_DOWN_ARROW:
			if (current_lex < member + 133)
				if (err = show_current_lex(++current_lex))
					return(err);
			break;

		case KEY_UP_ARROW:
		 	if (current_lex > member)
				if (err = show_current_lex(--current_lex))
					return(err);
			break;

 		case KEY_PAGE_DOWN:
			if (lock_total - ((lock_page + 1) * 20) > 0) {
				lock_page++;
				if (err = paint_lock_list())
					return(err);
			}
			break;

		case KEY_PAGE_UP:
			if (lock_page > 0) {
				lock_page--;
				if (err = paint_lock_list())
					return(err);
			}
			break;


		case OK:
			resulting_lex = (LEX *) lfind((char *) &key_structure, (char *) member, &elements, sizeof(LEX), compare_lex);
			if (!resulting_lex)
 				crummy = 1;
			else
				if (err = show_current_lex(current_lex = resulting_lex))
					return(err);
			break;

		default:
			break;
 		}


	} while (1);

}

int get_name(s)
char *s;
{
	int position = 0;
	int keystroke;

	while (1) {
		if (grabkey(&keystroke, INKEY_NOECHO)) {

			if (isprint(keystroke) && position < 17) {
				if (keystroke == '-' || keystroke == '+')
					return(keystroke);
				else {
					s[position] = keystroke;
					wwrite1(keystroke, ww_lock_control);
	 				wwcurrgt(1, ww_lock_control);
					wwshow2();
					position++;
				}

			} else switch (keystroke) {

			case CR:
				if (position > 0) {
					s[position] = EOS;
					return(OK);
				} else
					return(KEY_DOWN_ARROW);

				break;

			case BS:
				if (position > 0) {
					s[position] = EOS;
					wwcurlft(1, ww_lock_control);
					wwrite1(SPACE, ww_lock_control);
					wwshow2();
					position--;
				}
				break;

			case ESC:
				return(ESC);
				break;

			default:
				break;
			}

		} else switch (keystroke) {
		case KEY_DOWN_ARROW:
		case KEY_UP_ARROW:
		case KEY_PAGE_DOWN:
		case KEY_PAGE_UP:
			return(keystroke);
			break;

		default:
			break;
		}
	}
}

int paint_lock_list()
{
	int lock_count;
	LEX *current_lex = member;

	for (lock_count = 1; lock_count <= (lock_page + 1) * 20 && lock_count <= lock_total; lock_count++) {
		while (current_lex->vote != STATION_LOCKED)
			current_lex++;

		if (lock_count >= (lock_page * 20) + 1) {
			if (err = ww_message(current_lex->name, (lock_count - 1) % 20, 0,  NORMAL_VIDEO, ww_lock_list))
				return(err);

		}
		current_lex++;
	}

	/* if there are any more slots left on this page of list, blank them out */
	for ( ; lock_count <= (lock_page + 1) * 20; lock_count++)
 	if (err = ww_message("", (lock_count - 1) % 20, 0, NORMAL_VIDEO, ww_lock_list))
		return(err);

	if (err = wwshow2())
		return(err);

	return(OK);
}


int show_current_lex(current_lex)
LEX *current_lex;
{
	char buffer[BUFFER_LENGTH];

	sprintf(buffer, lock_current_station, current_lex->name);
	if (err = ww_message(buffer, 3, 0, BOLD_VIDEO, ww_lock_control))
		return(err);

	return(OK);
}


int compare_lex(lex1, lex2)
LEX *lex1, *lex2;
{

	return(strnicmp(lex1->name, lex2->name, strlen(lex1->name)));
}

char *rtrim(s)
char *s;
{
	char *p;

	for (p = s + strlen(s) - 1; *p == ' ' && p >= s; p--)
		;

	*(p + 1) = '\0';
	return (s);
}

load_seating()
{
	FILE *seating;
	char seat_record[50];
	char seating_fname[25];
	char *rtrim();
	int loop, lex_index, seat_number;
	int compare_member();



	sprintf(seating_fname, "C:\\VOTES\\H%s.SEA", seating_date);
	if (!(seating = fopen(seating_fname, "rt"))) {
		fprintf(stderr, "disaster: seating file not found\n\007");
		exit(1);
	}

	lex_index = 0;

	for (loop = 0; loop < 136; loop++) {
		if (!(fgets(seat_record, 50, seating))) {
			fprintf(stderr, "disaster: mangled seating file\n\007");
			exit(1);
		}

		seat_number = atoi(seat_record);
		if (loop != seat_number - 1) {
			fprintf(stderr, "disaster: synchronization error in seating file\n\007");
			exit(1);
		}

		if (seat_number == 69 || seat_number == 91)
			continue;

		if (seat_number == 136) {
			strcpy(member[lex_index].name, mister_speaker);
			strncat(member[lex_index].name, seat_record + 3, 25);
		} else
			strncpy(member[lex_index].name, seat_record + 3, 30);

		member[lex_index].seat = seat_number;

		lex_index++;
	}

	qsort((char *) member, 133, sizeof(LEX), compare_member);

	/* trim spaces from members' names */
	for (loop = 0; member[loop].seat; loop++)
		rtrim(member[loop].name);
}


int compare_member(member1, member2)
LEX *member1, *member2;
{
	int loop;
	char name1[31], name2[31];

	/* 22 Jan 88: modifed for telephone sort */

	strcpy(name1, member1->name);
	strcpy(name2, member2->name);

	for (loop = 0; loop < strlen(name1); loop++)
		name1[loop] = tolower(name1[loop]);

	for (loop = 0; loop < strlen(name2); loop++)
		name2[loop] = tolower(name2[loop]);

	pause();

	return(strcmp(name1, name2));
}


load_parm_file()
{
	FILE *parameter;
	char input_buffer[81];
	int loop;
	char *malloc();


	if (!(parameter = fopen(parm_fname, "rt"))) {
		fprintf(stderr, "disaster: parameter file not found\n\007");
		exit(1);
	}

	if (!(fgets(input_buffer, 81, parameter))) {
		fprintf(stderr, missing_parm);
		exit(1);
	}

	input_buffer[strlen(input_buffer) - 1] = '\0';		/* eliminate the newline */
	strcpy(seating_date, input_buffer);

	/* as for the three title lines, just pull them in and forget them */
	for (loop = 0; loop < 3; loop++) {
		if (!(fgets(input_buffer, 81, parameter))) {
			fprintf(stderr, missing_parm);
			exit(1);
		}
	}


	if (!(fgets(input_buffer, 81, parameter))) {
		fprintf(stderr, missing_parm);
		exit(1);
	}
	session_number = atoi(input_buffer);

}
