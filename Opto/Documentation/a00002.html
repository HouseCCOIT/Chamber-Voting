<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PAC-DEV-OPTOMMP-CPLUS: O22SnapIoMemMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PAC-DEV-OPTOMMP-CPLUS
   &#160;<span id="projectnumber">4.0</span>
   </div>
   <div id="projectbrief">OptoMMP C++ SDK for Win32 or Linux</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a00058.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">O22SnapIoMemMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="a00002.html" title="The O22SnapIoMemMap C++ class is used to communicate from a computer to an Opto 22 OptoMMP device...">O22SnapIoMemMap</a> C++ class is used to communicate from a computer to an Opto 22 OptoMMP device.  
 <a href="a00002.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00051_source.html">O22SIOMM.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb26f636587ab7e13d32d8c717c30633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#acb26f636587ab7e13d32d8c717c30633">OpenEnet</a> (const char *pchIpAddressArg, int nPort, int nOpenTimeOutMS, int nAutoPUC)</td></tr>
<tr class="memdesc:acb26f636587ab7e13d32d8c717c30633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous (unblocked) connection attempt to an OptoMMP device.  <a href="#acb26f636587ab7e13d32d8c717c30633">More...</a><br /></td></tr>
<tr class="separator:acb26f636587ab7e13d32d8c717c30633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8643ce7feb741af51d0b8c30a50c51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51">OpenEnet2</a> (const char *pchIpAddressArg, int nPort, int nOpenTimeOutMS, int nAutoPUC, int nConnectionType)</td></tr>
<tr class="memdesc:a0b8643ce7feb741af51d0b8c30a50c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the connection process to an OptoMMP device.  <a href="#a0b8643ce7feb741af51d0b8c30a50c51">More...</a><br /></td></tr>
<tr class="separator:a0b8643ce7feb741af51d0b8c30a50c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416aa8c4b0f05aa72337fb6a637d8e35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a416aa8c4b0f05aa72337fb6a637d8e35">OpenSerial</a> (int nPort, uint8_t nAddress, int nBaudRate, int nOpenTimeOutMS, int nAutoPUC)</td></tr>
<tr class="memdesc:a416aa8c4b0f05aa72337fb6a637d8e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a serial OptoMMP device (SNAP-PAC-SB1 or SNAP-PAC-SB2).  <a href="#a416aa8c4b0f05aa72337fb6a637d8e35">More...</a><br /></td></tr>
<tr class="separator:a416aa8c4b0f05aa72337fb6a637d8e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ead7dc892ded3b8ba6a8a926a05ac4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a6ead7dc892ded3b8ba6a8a926a05ac4e">OpenSerialPassThru</a> (char *pchIpAddressArg, int nPort, int nSerialPort, uint8_t nSerialAddress, int nSerialBaudRate, bool bTwoWire, int nOpenTimeOutMS, int nAutoPUC, int nConnectionType=SIOMM_TCP)</td></tr>
<tr class="memdesc:a6ead7dc892ded3b8ba6a8a926a05ac4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a serial OptoMMP device (SNAP-PAC-SB1 or SNAP-PAC-SB2) through an Ethernet controller.  <a href="#a6ead7dc892ded3b8ba6a8a926a05ac4e">More...</a><br /></td></tr>
<tr class="separator:a6ead7dc892ded3b8ba6a8a926a05ac4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91379d7151aae4e777fc3f0d761b5b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0">IsOpenDone</a> ()</td></tr>
<tr class="memdesc:ab91379d7151aae4e777fc3f0d761b5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after <a class="el" href="a00002.html#acb26f636587ab7e13d32d8c717c30633" title="Starts an asynchronous (unblocked) connection attempt to an OptoMMP device. ">OpenEnet()</a> or <a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51" title="Starts the connection process to an OptoMMP device. ">OpenEnet2()</a> to determine if the connection has completed yet.  <a href="#ab91379d7151aae4e777fc3f0d761b5b0">More...</a><br /></td></tr>
<tr class="separator:ab91379d7151aae4e777fc3f0d761b5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5146ca6f2029216d1dda70f229c266bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5146ca6f2029216d1dda70f229c266bd">Close</a> ()</td></tr>
<tr class="memdesc:a5146ca6f2029216d1dda70f229c266bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection to the OptoMMP device.  <a href="#a5146ca6f2029216d1dda70f229c266bd">More...</a><br /></td></tr>
<tr class="separator:a5146ca6f2029216d1dda70f229c266bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa442807fa10afedac352a5e0d6e9c0cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa442807fa10afedac352a5e0d6e9c0cb">SetCommOptions</a> (int nTimeOutMS, int nReserved)</td></tr>
<tr class="memdesc:aa442807fa10afedac352a5e0d6e9c0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set communication options, such as the connection's communication timeout value.  <a href="#aa442807fa10afedac352a5e0d6e9c0cb">More...</a><br /></td></tr>
<tr class="separator:aa442807fa10afedac352a5e0d6e9c0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b642849a9ad27380b8ab3b8c454a30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a71b642849a9ad27380b8ab3b8c454a30">GetCommTimeout</a> ()</td></tr>
<tr class="memdesc:a71b642849a9ad27380b8ab3b8c454a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current timeout period as set by <a class="el" href="a00002.html#aa442807fa10afedac352a5e0d6e9c0cb" title="Set communication options, such as the connection&#39;s communication timeout value. ">SetCommOptions()</a>  <a href="#a71b642849a9ad27380b8ab3b8c454a30">More...</a><br /></td></tr>
<tr class="separator:a71b642849a9ad27380b8ab3b8c454a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d18ecf07b8c4eca4e3dd73dac20675"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a61d18ecf07b8c4eca4e3dd73dac20675">BuildWriteBlockRequest</a> (uint8_t *pbyWriteBlockRequest, uint8_t byTransactionLabel, uint32_t dwDestinationOffset, uint16_t wDataLength, uint8_t *pbyBlockData)</td></tr>
<tr class="memdesc:a61d18ecf07b8c4eca4e3dd73dac20675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a write block request packet.  <a href="#a61d18ecf07b8c4eca4e3dd73dac20675">More...</a><br /></td></tr>
<tr class="separator:a61d18ecf07b8c4eca4e3dd73dac20675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c7b6b1c59b0bd1adf591733a3d9f30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a35c7b6b1c59b0bd1adf591733a3d9f30">UnpackWriteResponse</a> (uint8_t *pbyWriteQuadletResponse, uint8_t *pbyTransactionLabel, uint8_t *pbyResponseCode)</td></tr>
<tr class="memdesc:a35c7b6b1c59b0bd1adf591733a3d9f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a write response packet.  <a href="#a35c7b6b1c59b0bd1adf591733a3d9f30">More...</a><br /></td></tr>
<tr class="separator:a35c7b6b1c59b0bd1adf591733a3d9f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9a148ad45d90734045a0b58b066e19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8b9a148ad45d90734045a0b58b066e19">BuildReadBlockRequest</a> (uint8_t *pbyReadBlockRequest, uint8_t byTransactionLabel, uint32_t dwDestinationOffset, uint16_t wDataLength)</td></tr>
<tr class="memdesc:a8b9a148ad45d90734045a0b58b066e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a read block request packet.  <a href="#a8b9a148ad45d90734045a0b58b066e19">More...</a><br /></td></tr>
<tr class="separator:a8b9a148ad45d90734045a0b58b066e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738db224f75f0e8b2120ffaabe2f62bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a738db224f75f0e8b2120ffaabe2f62bc">UnpackReadBlockResponse</a> (uint8_t *pbyReadBlockResponse, uint8_t *pbyTransactionLabel, uint8_t *pbyResponseCode, uint16_t *pwDataLength, uint8_t *pbyBlockData)</td></tr>
<tr class="memdesc:a738db224f75f0e8b2120ffaabe2f62bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a read response.  <a href="#a738db224f75f0e8b2120ffaabe2f62bc">More...</a><br /></td></tr>
<tr class="separator:a738db224f75f0e8b2120ffaabe2f62bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45b610c506072bf3faaaff5ef19791e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae45b610c506072bf3faaaff5ef19791e">ReadQuad</a> (uint32_t dwDestOffset, uint32_t *pdwQuadlet)</td></tr>
<tr class="memdesc:ae45b610c506072bf3faaaff5ef19791e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a quad (4 bytes) of data from the given offset on the brain.  <a href="#ae45b610c506072bf3faaaff5ef19791e">More...</a><br /></td></tr>
<tr class="separator:ae45b610c506072bf3faaaff5ef19791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3dac4dbe900d6c3d07c64012183058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a3e3dac4dbe900d6c3d07c64012183058">WriteQuad</a> (uint32_t dwDestOffset, uint32_t dwQuadlet)</td></tr>
<tr class="memdesc:a3e3dac4dbe900d6c3d07c64012183058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a quad (4 bytes) of data to the given offset on the brain.  <a href="#a3e3dac4dbe900d6c3d07c64012183058">More...</a><br /></td></tr>
<tr class="separator:a3e3dac4dbe900d6c3d07c64012183058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0b2e71e9bbbf39af67582363678d0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#acc0b2e71e9bbbf39af67582363678d0e">ReadFloat</a> (uint32_t dwDestOffset, float *pfValue)</td></tr>
<tr class="memdesc:acc0b2e71e9bbbf39af67582363678d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a float (4 bytes interpreted as a float) of data from the given offset on the brain.  <a href="#acc0b2e71e9bbbf39af67582363678d0e">More...</a><br /></td></tr>
<tr class="separator:acc0b2e71e9bbbf39af67582363678d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569087f77535891286008e178599e21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9569087f77535891286008e178599e21">WriteFloat</a> (uint32_t dwDestOffset, float fValue)</td></tr>
<tr class="memdesc:a9569087f77535891286008e178599e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a float (4 bytes) of data to the given offset on the brain.  <a href="#a9569087f77535891286008e178599e21">More...</a><br /></td></tr>
<tr class="separator:a9569087f77535891286008e178599e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602bcdea6e76af88f2c9cb54b00b3ab0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a602bcdea6e76af88f2c9cb54b00b3ab0">ReadBlock</a> (const uint32_t dwDestOffset, const uint16_t wDataLength, uint8_t *pbyData)</td></tr>
<tr class="memdesc:a602bcdea6e76af88f2c9cb54b00b3ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a block of data from the I/O unit.  <a href="#a602bcdea6e76af88f2c9cb54b00b3ab0">More...</a><br /></td></tr>
<tr class="separator:a602bcdea6e76af88f2c9cb54b00b3ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3f1044e5ef9bc8da8cec03136a9fa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ada3f1044e5ef9bc8da8cec03136a9fa1">WriteBlock</a> (const uint32_t dwDestOffset, const uint16_t wDataLength, uint8_t *pbyData)</td></tr>
<tr class="memdesc:ada3f1044e5ef9bc8da8cec03136a9fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a block of data to the I/O unit.  <a href="#ada3f1044e5ef9bc8da8cec03136a9fa1">More...</a><br /></td></tr>
<tr class="separator:ada3f1044e5ef9bc8da8cec03136a9fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21afd2b6984a998275e40ee743472f18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a21afd2b6984a998275e40ee743472f18">ReadBlockAsIntegers</a> (uint32_t dwDestOffset, uint16_t wDataLength, int *pnData)</td></tr>
<tr class="memdesc:a21afd2b6984a998275e40ee743472f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a chunk of memory from the brain as an array of integers.  <a href="#a21afd2b6984a998275e40ee743472f18">More...</a><br /></td></tr>
<tr class="separator:a21afd2b6984a998275e40ee743472f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993a491a7999ef681feee4252d54ef2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab993a491a7999ef681feee4252d54ef2">WriteBlockAsIntegers</a> (uint32_t dwDestOffset, uint16_t wDataLength, int *pnData)</td></tr>
<tr class="memdesc:ab993a491a7999ef681feee4252d54ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array of integers to the I/O unit.  <a href="#ab993a491a7999ef681feee4252d54ef2">More...</a><br /></td></tr>
<tr class="separator:ab993a491a7999ef681feee4252d54ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a990793af87d1b9f423c79ff14028b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2a990793af87d1b9f423c79ff14028b0">ReadBlockAsFloats</a> (uint32_t dwDestOffset, uint16_t wDataLength, float *pfData)</td></tr>
<tr class="memdesc:a2a990793af87d1b9f423c79ff14028b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a chunk of memory from the brain as an array of integers.  <a href="#a2a990793af87d1b9f423c79ff14028b0">More...</a><br /></td></tr>
<tr class="separator:a2a990793af87d1b9f423c79ff14028b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38edcee14fb6d62586953abdbd56af87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a38edcee14fb6d62586953abdbd56af87">WriteBlockAsFloats</a> (uint32_t dwDestOffset, uint16_t wDataLength, float *pfData)</td></tr>
<tr class="memdesc:a38edcee14fb6d62586953abdbd56af87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array of floats to the I/O unit.  <a href="#a38edcee14fb6d62586953abdbd56af87">More...</a><br /></td></tr>
<tr class="separator:a38edcee14fb6d62586953abdbd56af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38d7bf6a725438ebaea59a4bb23ddcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ad38d7bf6a725438ebaea59a4bb23ddcb">GetStatusPUC</a> (int *pnPUCFlag)</td></tr>
<tr class="memdesc:ad38d7bf6a725438ebaea59a4bb23ddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the Powerup Clear flag from the I/O units status area.  <a href="#ad38d7bf6a725438ebaea59a4bb23ddcb">More...</a><br /></td></tr>
<tr class="separator:ad38d7bf6a725438ebaea59a4bb23ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf18948fcc3155dd74acaf5bccc120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5eaf18948fcc3155dd74acaf5bccc120">GetStatusLastError</a> (int *pnErrorCode)</td></tr>
<tr class="memdesc:a5eaf18948fcc3155dd74acaf5bccc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the last error code from the I/O units status area.  <a href="#a5eaf18948fcc3155dd74acaf5bccc120">More...</a><br /></td></tr>
<tr class="separator:a5eaf18948fcc3155dd74acaf5bccc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f1bc483187ff1336725b1c08001263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a34f1bc483187ff1336725b1c08001263">GetStatusBootpAlways</a> (int *pnBootpAlways)</td></tr>
<tr class="memdesc:a34f1bc483187ff1336725b1c08001263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the "BootP always" flag from the I/O units status area.  <a href="#a34f1bc483187ff1336725b1c08001263">More...</a><br /></td></tr>
<tr class="separator:a34f1bc483187ff1336725b1c08001263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad765c02e9feb94244af6dd0fdf0b0e4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ad765c02e9feb94244af6dd0fdf0b0e4c">GetStatusDegrees</a> (int *pnDegrees)</td></tr>
<tr class="memdesc:ad765c02e9feb94244af6dd0fdf0b0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of the Degrees flag in the I/O units status area.  <a href="#ad765c02e9feb94244af6dd0fdf0b0e4c">More...</a><br /></td></tr>
<tr class="separator:ad765c02e9feb94244af6dd0fdf0b0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8963fcd5fd7223a86cd93839564ec612"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8963fcd5fd7223a86cd93839564ec612">GetStatusWatchdogTime</a> (int *pnTimeMS)</td></tr>
<tr class="memdesc:a8963fcd5fd7223a86cd93839564ec612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the communication watchdog time setting from the I/O units status area.  <a href="#a8963fcd5fd7223a86cd93839564ec612">More...</a><br /></td></tr>
<tr class="separator:a8963fcd5fd7223a86cd93839564ec612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49226018653f75b56df868fdad7a4fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac49226018653f75b56df868fdad7a4fa">GetStatusVersionEx</a> (<a class="el" href="a00042.html">SIOMM_StatusVersion</a> *pVersionData)</td></tr>
<tr class="memdesc:ac49226018653f75b56df868fdad7a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version information from the I/O unit status area.  <a href="#ac49226018653f75b56df868fdad7a4fa">More...</a><br /></td></tr>
<tr class="separator:ac49226018653f75b56df868fdad7a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a990a80d42cbe929d112e039cae7345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0a990a80d42cbe929d112e039cae7345">GetStatusHardwareEx</a> (<a class="el" href="a00038.html">SIOMM_StatusHardware</a> *pHardwareData)</td></tr>
<tr class="memdesc:a0a990a80d42cbe929d112e039cae7345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read hardware details from the I/O unit status area.  <a href="#a0a990a80d42cbe929d112e039cae7345">More...</a><br /></td></tr>
<tr class="separator:a0a990a80d42cbe929d112e039cae7345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eec67c150a0a381529f2398762b3710"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9eec67c150a0a381529f2398762b3710">GetStatusHardwareEx2</a> (<a class="el" href="a00039.html">SIOMM_StatusHardware2</a> *pHardwareData)</td></tr>
<tr class="memdesc:a9eec67c150a0a381529f2398762b3710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read hardware details from the I/O unit status area.  <a href="#a9eec67c150a0a381529f2398762b3710">More...</a><br /></td></tr>
<tr class="separator:a9eec67c150a0a381529f2398762b3710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840e1ec36b181e4ebc4aa596b8d4f324"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a840e1ec36b181e4ebc4aa596b8d4f324">GetStatusNetworkEx</a> (<a class="el" href="a00040.html">SIOMM_StatusNetwork</a> *pNetworkData)</td></tr>
<tr class="memdesc:a840e1ec36b181e4ebc4aa596b8d4f324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read current IPv4 networking details from the I/O unit status area.  <a href="#a840e1ec36b181e4ebc4aa596b8d4f324">More...</a><br /></td></tr>
<tr class="separator:a840e1ec36b181e4ebc4aa596b8d4f324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444d119db2e6c44d245758875b70db1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a444d119db2e6c44d245758875b70db1e">GetStatusNetworkEx2</a> (<a class="el" href="a00041.html">SIOMM_StatusNetwork2</a> *pNetworkData)</td></tr>
<tr class="memdesc:a444d119db2e6c44d245758875b70db1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read current networking details from the I/O units status area.  <a href="#a444d119db2e6c44d245758875b70db1e">More...</a><br /></td></tr>
<tr class="separator:a444d119db2e6c44d245758875b70db1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44009515c1848a8a44b975972678680a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a44009515c1848a8a44b975972678680a">GetStatusWriteEx</a> (<a class="el" href="a00043.html">SIOMM_StatusWrite</a> *pStatusWriteData)</td></tr>
<tr class="memdesc:a44009515c1848a8a44b975972678680a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current contents of the Status Read/Write area of the I/O unit.  <a href="#a44009515c1848a8a44b975972678680a">More...</a><br /></td></tr>
<tr class="separator:a44009515c1848a8a44b975972678680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531e5a2cc65b74b3a6d7d532a548ab3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9531e5a2cc65b74b3a6d7d532a548ab3">SetStatusWriteEx</a> (<a class="el" href="a00043.html">SIOMM_StatusWrite</a> StatusWriteData)</td></tr>
<tr class="memdesc:a9531e5a2cc65b74b3a6d7d532a548ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write new data to the Status Read/Write area of the I/O unit.  <a href="#a9531e5a2cc65b74b3a6d7d532a548ab3">More...</a><br /></td></tr>
<tr class="separator:a9531e5a2cc65b74b3a6d7d532a548ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ffd2fc7f4e096b6d7b30fce99e320"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aca8ffd2fc7f4e096b6d7b30fce99e320">SetStatusOperation</a> (int nOpCode)</td></tr>
<tr class="memdesc:aca8ffd2fc7f4e096b6d7b30fce99e320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given opcode to the SIOMM_STATUS_WRITE_OPERATION location in the I/O units memory map.  <a href="#aca8ffd2fc7f4e096b6d7b30fce99e320">More...</a><br /></td></tr>
<tr class="separator:aca8ffd2fc7f4e096b6d7b30fce99e320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d879d816219fd91766b64941e8650"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a652d879d816219fd91766b64941e8650">SetStatusBootpRequest</a> (int nFlag)</td></tr>
<tr class="memdesc:a652d879d816219fd91766b64941e8650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I/O unit to send BootP or DHCP request when turned on.  <a href="#a652d879d816219fd91766b64941e8650">More...</a><br /></td></tr>
<tr class="separator:a652d879d816219fd91766b64941e8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648312735cd629ea266e3a6da2044e06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a648312735cd629ea266e3a6da2044e06">SetStatusDegrees</a> (int nDegFlag)</td></tr>
<tr class="memdesc:a648312735cd629ea266e3a6da2044e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the I/O unit to report temperatures in degrees Celsius or degrees Fahrenheit.  <a href="#a648312735cd629ea266e3a6da2044e06">More...</a><br /></td></tr>
<tr class="separator:a648312735cd629ea266e3a6da2044e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0512ce0ea20da408febac0ae4d65e684"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0512ce0ea20da408febac0ae4d65e684">SetStatusWatchdogTime</a> (int nTimeMS)</td></tr>
<tr class="memdesc:a0512ce0ea20da408febac0ae4d65e684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set watchdog time in milliseconds.  <a href="#a0512ce0ea20da408febac0ae4d65e684">More...</a><br /></td></tr>
<tr class="separator:a0512ce0ea20da408febac0ae4d65e684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c21c9411825dfea24aa142a59bcf93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a41c21c9411825dfea24aa142a59bcf93">GetDateTime</a> (char *pchDateTime)</td></tr>
<tr class="memdesc:a41c21c9411825dfea24aa142a59bcf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current date and time time from the I/O unit.  <a href="#a41c21c9411825dfea24aa142a59bcf93">More...</a><br /></td></tr>
<tr class="separator:a41c21c9411825dfea24aa142a59bcf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26ddc14ee6be41d0eb4e75f840a6527"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae26ddc14ee6be41d0eb4e75f840a6527">SetDateTime</a> (char *pchDateTime)</td></tr>
<tr class="memdesc:ae26ddc14ee6be41d0eb4e75f840a6527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I/O units date and time.  <a href="#ae26ddc14ee6be41d0eb4e75f840a6527">More...</a><br /></td></tr>
<tr class="separator:ae26ddc14ee6be41d0eb4e75f840a6527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa67b254f1ff7e473f09e6d334245ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#acfa67b254f1ff7e473f09e6d334245ae">GetSerialModuleConfigurationEx</a> (int nSerialPort, <a class="el" href="a00037.html">SIOMM_SerialModuleConfigArea</a> *pConfigData)</td></tr>
<tr class="memdesc:acfa67b254f1ff7e473f09e6d334245ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the configuration of the SNAP serial communication modules on the I/O unit.  <a href="#acfa67b254f1ff7e473f09e6d334245ae">More...</a><br /></td></tr>
<tr class="separator:acfa67b254f1ff7e473f09e6d334245ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a324f084717a9dbdf4a28f17d5133"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a306a324f084717a9dbdf4a28f17d5133">SetSerialModuleConfigurationEx</a> (int nSerialPort, <a class="el" href="a00037.html">SIOMM_SerialModuleConfigArea</a> ConfigData)</td></tr>
<tr class="memdesc:a306a324f084717a9dbdf4a28f17d5133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write configuration data for a SNAP serial communication module.  <a href="#a306a324f084717a9dbdf4a28f17d5133">More...</a><br /></td></tr>
<tr class="separator:a306a324f084717a9dbdf4a28f17d5133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d0fd4b0f948f4b289df75b041fd847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a16d0fd4b0f948f4b289df75b041fd847">ConfigurePoint</a> (int nPoint, int nPointType)</td></tr>
<tr class="memdesc:a16d0fd4b0f948f4b289df75b041fd847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the I/O unit what kind of point is at a given location.  <a href="#a16d0fd4b0f948f4b289df75b041fd847">More...</a><br /></td></tr>
<tr class="separator:a16d0fd4b0f948f4b289df75b041fd847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d17c4c7d9616d871e6fda7952f3f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a055d17c4c7d9616d871e6fda7952f3f2">GetModuleType</a> (int nPoint, int *pnModuleType)</td></tr>
<tr class="memdesc:a055d17c4c7d9616d871e6fda7952f3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the point type of a given point back from the I/O unit.  <a href="#a055d17c4c7d9616d871e6fda7952f3f2">More...</a><br /></td></tr>
<tr class="separator:a055d17c4c7d9616d871e6fda7952f3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737d839061105368bf6c786d66064a7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a737d839061105368bf6c786d66064a7a">GetPtConfigurationEx3</a> (int nPoint, <a class="el" href="a00029.html">SIOMM_PointConfigArea3</a> *pData)</td></tr>
<tr class="memdesc:a737d839061105368bf6c786d66064a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full configuration data for a given point.  <a href="#a737d839061105368bf6c786d66064a7a">More...</a><br /></td></tr>
<tr class="separator:a737d839061105368bf6c786d66064a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e90aa3e05c5949558e3202cf75f789"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a08e90aa3e05c5949558e3202cf75f789">GetPtConfigurationEx2</a> (int nPoint, <a class="el" href="a00028.html">SIOMM_PointConfigArea2</a> *pData)</td></tr>
<tr class="memdesc:a08e90aa3e05c5949558e3202cf75f789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full configuration data for a given point.  <a href="#a08e90aa3e05c5949558e3202cf75f789">More...</a><br /></td></tr>
<tr class="separator:a08e90aa3e05c5949558e3202cf75f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f502b4c4c50f220b06ddc071c13760"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af4f502b4c4c50f220b06ddc071c13760">GetPtConfigurationEx</a> (int nPoint, <a class="el" href="a00027.html">SIOMM_PointConfigArea</a> *pData)</td></tr>
<tr class="memdesc:af4f502b4c4c50f220b06ddc071c13760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full configuration data for a given point.  <a href="#af4f502b4c4c50f220b06ddc071c13760">More...</a><br /></td></tr>
<tr class="separator:af4f502b4c4c50f220b06ddc071c13760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae32b691650b63e3b548697f98e1019"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a3ae32b691650b63e3b548697f98e1019">SetPtConfigurationEx3</a> (int nPoint, <a class="el" href="a00029.html">SIOMM_PointConfigArea3</a> Data)</td></tr>
<tr class="memdesc:a3ae32b691650b63e3b548697f98e1019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the full configuration for a given point.  <a href="#a3ae32b691650b63e3b548697f98e1019">More...</a><br /></td></tr>
<tr class="separator:a3ae32b691650b63e3b548697f98e1019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1668052209bef6021c1c05b1a0b09b19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a1668052209bef6021c1c05b1a0b09b19">SetPtConfigurationEx2</a> (int nPoint, <a class="el" href="a00028.html">SIOMM_PointConfigArea2</a> Data)</td></tr>
<tr class="memdesc:a1668052209bef6021c1c05b1a0b09b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the full configuration for a given point.  <a href="#a1668052209bef6021c1c05b1a0b09b19">More...</a><br /></td></tr>
<tr class="separator:a1668052209bef6021c1c05b1a0b09b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a313b4eb29413114c19e6d9fceff794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2a313b4eb29413114c19e6d9fceff794">SetPtConfigurationEx</a> (int nPoint, <a class="el" href="a00027.html">SIOMM_PointConfigArea</a> Data)</td></tr>
<tr class="memdesc:a2a313b4eb29413114c19e6d9fceff794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the full configuration for a given point.  <a href="#a2a313b4eb29413114c19e6d9fceff794">More...</a><br /></td></tr>
<tr class="separator:a2a313b4eb29413114c19e6d9fceff794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2689478ce4b9a316bcfc4df20a3a5f48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2689478ce4b9a316bcfc4df20a3a5f48">SetDigPtConfiguration</a> (int nPoint, int nPointType, int nFeature)</td></tr>
<tr class="memdesc:a2689478ce4b9a316bcfc4df20a3a5f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a digital point.  <a href="#a2689478ce4b9a316bcfc4df20a3a5f48">More...</a><br /></td></tr>
<tr class="separator:a2689478ce4b9a316bcfc4df20a3a5f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a51fbb0e1c6fa904ad77290ee9baad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae8a51fbb0e1c6fa904ad77290ee9baad">SetAnaPtConfiguration</a> (int nPoint, int nPointType, float fOffset, float fGain, float fHiScale, float fLoScale)</td></tr>
<tr class="memdesc:ae8a51fbb0e1c6fa904ad77290ee9baad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure an analog point.  <a href="#ae8a51fbb0e1c6fa904ad77290ee9baad">More...</a><br /></td></tr>
<tr class="separator:ae8a51fbb0e1c6fa904ad77290ee9baad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad627356f69630819afa283e3215a52ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ad627356f69630819afa283e3215a52ad">SetPtWatchdog</a> (int nPoint, float fValue, int nEnabled)</td></tr>
<tr class="memdesc:ad627356f69630819afa283e3215a52ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a watchdog value for a point.  <a href="#ad627356f69630819afa283e3215a52ad">More...</a><br /></td></tr>
<tr class="separator:ad627356f69630819afa283e3215a52ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f264e821be1933df5c4c85cd7a6d03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab2f264e821be1933df5c4c85cd7a6d03">GetDigPtState</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:ab2f264e821be1933df5c4c85cd7a6d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of a digital point.  <a href="#ab2f264e821be1933df5c4c85cd7a6d03">More...</a><br /></td></tr>
<tr class="separator:ab2f264e821be1933df5c4c85cd7a6d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f609e0078d174e27babcbb3559f424"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a32f609e0078d174e27babcbb3559f424">GetDigPtOnLatch</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:a32f609e0078d174e27babcbb3559f424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the on-latch state of a digital point.  <a href="#a32f609e0078d174e27babcbb3559f424">More...</a><br /></td></tr>
<tr class="separator:a32f609e0078d174e27babcbb3559f424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe6771952934e23144e6d524c789fec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aefe6771952934e23144e6d524c789fec">GetDigPtOffLatch</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:aefe6771952934e23144e6d524c789fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the off-latch state of a digital point.  <a href="#aefe6771952934e23144e6d524c789fec">More...</a><br /></td></tr>
<tr class="separator:aefe6771952934e23144e6d524c789fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114a1f748d3e2f48f5432ccb4dd0ebbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a114a1f748d3e2f48f5432ccb4dd0ebbe">GetDigPtCounterState</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:a114a1f748d3e2f48f5432ccb4dd0ebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active counter state of a digital point.  <a href="#a114a1f748d3e2f48f5432ccb4dd0ebbe">More...</a><br /></td></tr>
<tr class="separator:a114a1f748d3e2f48f5432ccb4dd0ebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f3ac39eac9abe765e75a9696210749"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa2f3ac39eac9abe765e75a9696210749">GetDigPtCounts</a> (int nPoint, int *pnValue)</td></tr>
<tr class="memdesc:aa2f3ac39eac9abe765e75a9696210749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the counters of a digital point.  <a href="#aa2f3ac39eac9abe765e75a9696210749">More...</a><br /></td></tr>
<tr class="separator:aa2f3ac39eac9abe765e75a9696210749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b9a622279dac0972e9522279b31188"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af9b9a622279dac0972e9522279b31188">GetDigPtReadAreaEx</a> (int nPoint, <a class="el" href="a00019.html">SIOMM_DigPointReadArea</a> *pData)</td></tr>
<tr class="memdesc:af9b9a622279dac0972e9522279b31188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full state of a digital point.  <a href="#af9b9a622279dac0972e9522279b31188">More...</a><br /></td></tr>
<tr class="separator:af9b9a622279dac0972e9522279b31188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029543875d463f73e0444ba72988c0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2029543875d463f73e0444ba72988c0c">SetDigPtState</a> (int nPoint, int nState)</td></tr>
<tr class="memdesc:a2029543875d463f73e0444ba72988c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of a digital point.  <a href="#a2029543875d463f73e0444ba72988c0c">More...</a><br /></td></tr>
<tr class="separator:a2029543875d463f73e0444ba72988c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d63812852189001823740d90edfd902"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a4d63812852189001823740d90edfd902">SetDigPtCounterState</a> (int nPoint, int nState)</td></tr>
<tr class="memdesc:a4d63812852189001823740d90edfd902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn counters on or off for a digital point.  <a href="#a4d63812852189001823740d90edfd902">More...</a><br /></td></tr>
<tr class="separator:a4d63812852189001823740d90edfd902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4225e78c1b5cc5fe1bb897635b38edc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a4225e78c1b5cc5fe1bb897635b38edc4">ReadClearDigPtCounts</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:a4225e78c1b5cc5fe1bb897635b38edc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the counts value for a digital point.  <a href="#a4225e78c1b5cc5fe1bb897635b38edc4">More...</a><br /></td></tr>
<tr class="separator:a4225e78c1b5cc5fe1bb897635b38edc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bae288ee86837b2d36ca4f8961fec5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a4bae288ee86837b2d36ca4f8961fec5b">ReadClearDigPtOnLatch</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:a4bae288ee86837b2d36ca4f8961fec5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the on-latch state for a digital point.  <a href="#a4bae288ee86837b2d36ca4f8961fec5b">More...</a><br /></td></tr>
<tr class="separator:a4bae288ee86837b2d36ca4f8961fec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e3fb6242b3ca38dfc4b25a77d15086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa0e3fb6242b3ca38dfc4b25a77d15086">ReadClearDigPtOffLatch</a> (int nPoint, int *pnState)</td></tr>
<tr class="memdesc:aa0e3fb6242b3ca38dfc4b25a77d15086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the off-latch state of a digital point.  <a href="#aa0e3fb6242b3ca38dfc4b25a77d15086">More...</a><br /></td></tr>
<tr class="separator:aa0e3fb6242b3ca38dfc4b25a77d15086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610f37b8bb2d9f365e34b63a298057b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a610f37b8bb2d9f365e34b63a298057b9">GetDigBankPointStates</a> (int *pnPts63to32, int *pnPts31to0)</td></tr>
<tr class="memdesc:a610f37b8bb2d9f365e34b63a298057b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the status of the entire bank of standard density digital points.  <a href="#a610f37b8bb2d9f365e34b63a298057b9">More...</a><br /></td></tr>
<tr class="separator:a610f37b8bb2d9f365e34b63a298057b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fee24a811de395d3f6bad3955f3e9b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9fee24a811de395d3f6bad3955f3e9b0">GetDigBankOnLatchStates</a> (int *pnPts63to32, int *pnPts31to0)</td></tr>
<tr class="memdesc:a9fee24a811de395d3f6bad3955f3e9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the on-latch states of tge entire bank of standard density digital points.  <a href="#a9fee24a811de395d3f6bad3955f3e9b0">More...</a><br /></td></tr>
<tr class="separator:a9fee24a811de395d3f6bad3955f3e9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c47cff5f4ca1b8cd39cf435ae0baf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab5c47cff5f4ca1b8cd39cf435ae0baf8">GetDigBankOffLatchStates</a> (int *pnPts63to32, int *pnPts31to0)</td></tr>
<tr class="memdesc:ab5c47cff5f4ca1b8cd39cf435ae0baf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the off-latch states of tge entire bank of standard density digital points.  <a href="#ab5c47cff5f4ca1b8cd39cf435ae0baf8">More...</a><br /></td></tr>
<tr class="separator:ab5c47cff5f4ca1b8cd39cf435ae0baf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68786a1c39121dead9e408df1d36f2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae68786a1c39121dead9e408df1d36f2d">GetDigBankActCounterStates</a> (int *pnPts63to32, int *pnPts31to0)</td></tr>
<tr class="memdesc:ae68786a1c39121dead9e408df1d36f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the active counter states of tge entire bank of standard density digital points.  <a href="#ae68786a1c39121dead9e408df1d36f2d">More...</a><br /></td></tr>
<tr class="separator:ae68786a1c39121dead9e408df1d36f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805d5053b1f98f232ba86e3330870d5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a805d5053b1f98f232ba86e3330870d5b">GetDigBankReadAreaEx</a> (<a class="el" href="a00017.html">SIOMM_DigBankReadArea</a> *pData)</td></tr>
<tr class="memdesc:a805d5053b1f98f232ba86e3330870d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire standard density digital point bank in one shot.  <a href="#a805d5053b1f98f232ba86e3330870d5b">More...</a><br /></td></tr>
<tr class="separator:a805d5053b1f98f232ba86e3330870d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dbd8c01dc13791f289054dbb2a6b0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a01dbd8c01dc13791f289054dbb2a6b0d">SetDigBankPointStates</a> (int nPts63to32, int nPts31to0, int nMask63to32, int nMask31to0)</td></tr>
<tr class="memdesc:a01dbd8c01dc13791f289054dbb2a6b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the states of (potentially) all standard density digital points in one call.  <a href="#a01dbd8c01dc13791f289054dbb2a6b0d">More...</a><br /></td></tr>
<tr class="separator:a01dbd8c01dc13791f289054dbb2a6b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af123f37878a8ab1def70feaa0c01c763"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af123f37878a8ab1def70feaa0c01c763">SetDigBankOnMask</a> (int nPts63to32, int nPts31to0)</td></tr>
<tr class="memdesc:af123f37878a8ab1def70feaa0c01c763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of a subset of all standard density digital points on at once.  <a href="#af123f37878a8ab1def70feaa0c01c763">More...</a><br /></td></tr>
<tr class="separator:af123f37878a8ab1def70feaa0c01c763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa99c0ad6b78b4df1ad5ebe34b91026"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#abaa99c0ad6b78b4df1ad5ebe34b91026">SetDigBankOffMask</a> (int nPts63to32, int nPts31to0)</td></tr>
<tr class="memdesc:abaa99c0ad6b78b4df1ad5ebe34b91026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of a subset of all standard density digital points off at once.  <a href="#abaa99c0ad6b78b4df1ad5ebe34b91026">More...</a><br /></td></tr>
<tr class="separator:abaa99c0ad6b78b4df1ad5ebe34b91026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec269bf48f3f39a0cbc1e2b0031cbc1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aec269bf48f3f39a0cbc1e2b0031cbc1f">SetDigBankActCounterMask</a> (int nPts63to32, int nPts31to0)</td></tr>
<tr class="memdesc:aec269bf48f3f39a0cbc1e2b0031cbc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on the counters for a subset of all standard density digital points on at once.  <a href="#aec269bf48f3f39a0cbc1e2b0031cbc1f">More...</a><br /></td></tr>
<tr class="separator:aec269bf48f3f39a0cbc1e2b0031cbc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af948188dc86eb4890357414a6419786e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af948188dc86eb4890357414a6419786e">SetDigBankDeactCounterMask</a> (int nPts63to32, int nPts31to0)</td></tr>
<tr class="memdesc:af948188dc86eb4890357414a6419786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on the counters for a subset of all standard density digital points off at once.  <a href="#af948188dc86eb4890357414a6419786e">More...</a><br /></td></tr>
<tr class="separator:af948188dc86eb4890357414a6419786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7227aa02b4ff5ae8600f1519227f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab5d7227aa02b4ff5ae8600f1519227f6">GetHDDigitalPointState</a> (int nModule, int nPoint, int *pnState)</td></tr>
<tr class="memdesc:ab5d7227aa02b4ff5ae8600f1519227f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of a high-density digital point.  <a href="#ab5d7227aa02b4ff5ae8600f1519227f6">More...</a><br /></td></tr>
<tr class="separator:ab5d7227aa02b4ff5ae8600f1519227f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab788546808863b74da5c37887d1b3a1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab788546808863b74da5c37887d1b3a1d">GetHDDigitalPointOnLatch</a> (int nModule, int nPoint, int *pnState)</td></tr>
<tr class="memdesc:ab788546808863b74da5c37887d1b3a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the on-latch state of a high-density digital point.  <a href="#ab788546808863b74da5c37887d1b3a1d">More...</a><br /></td></tr>
<tr class="separator:ab788546808863b74da5c37887d1b3a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90215cf5621bfb4ccb5ad3ade132d873"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a90215cf5621bfb4ccb5ad3ade132d873">GetHDDigitalPointOffLatch</a> (int nModule, int nPoint, int *pnState)</td></tr>
<tr class="memdesc:a90215cf5621bfb4ccb5ad3ade132d873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the off-latch state of a high-density digital point.  <a href="#a90215cf5621bfb4ccb5ad3ade132d873">More...</a><br /></td></tr>
<tr class="separator:a90215cf5621bfb4ccb5ad3ade132d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0945787775130de619508bfeed4c28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aad0945787775130de619508bfeed4c28">GetHDDigitalPointCounts</a> (int nModule, int nPoint, int *pnCounts)</td></tr>
<tr class="memdesc:aad0945787775130de619508bfeed4c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current counter of a high-density digital point.  <a href="#aad0945787775130de619508bfeed4c28">More...</a><br /></td></tr>
<tr class="separator:aad0945787775130de619508bfeed4c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac5d970e7941b07abe9fada0e366acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aeac5d970e7941b07abe9fada0e366acf">SetHDDigitalPointState</a> (int nModule, int nPoint, int nState)</td></tr>
<tr class="memdesc:aeac5d970e7941b07abe9fada0e366acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of a high-density digital point.  <a href="#aeac5d970e7941b07abe9fada0e366acf">More...</a><br /></td></tr>
<tr class="separator:aeac5d970e7941b07abe9fada0e366acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861db449d8bfda289a8bbfb3961ffd6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a861db449d8bfda289a8bbfb3961ffd6a">ReadClearHDDigitalPointCounts</a> (int nModule, int nPoint, int *pnCounts)</td></tr>
<tr class="memdesc:a861db449d8bfda289a8bbfb3961ffd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the counts value for a high density digital point.  <a href="#a861db449d8bfda289a8bbfb3961ffd6a">More...</a><br /></td></tr>
<tr class="separator:a861db449d8bfda289a8bbfb3961ffd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f26bf943e5500fbb23aef94abffdb31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8f26bf943e5500fbb23aef94abffdb31">ReadClearHDDigitalPointOnLatch</a> (int nModule, int nPoint, int *pnState)</td></tr>
<tr class="memdesc:a8f26bf943e5500fbb23aef94abffdb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the on-latch value for a high density digital point.  <a href="#a8f26bf943e5500fbb23aef94abffdb31">More...</a><br /></td></tr>
<tr class="separator:a8f26bf943e5500fbb23aef94abffdb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4abd1441347c56542cf33617c578b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aec4abd1441347c56542cf33617c578b6">ReadClearHDDigitalPointOffLatch</a> (int nModule, int nPoint, int *pnState)</td></tr>
<tr class="memdesc:aec4abd1441347c56542cf33617c578b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the off-latch value for a high density digital point.  <a href="#aec4abd1441347c56542cf33617c578b6">More...</a><br /></td></tr>
<tr class="separator:aec4abd1441347c56542cf33617c578b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93f816fc67eb16437dbd9f6f6a485e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae93f816fc67eb16437dbd9f6f6a485e4">GetAnalogPointValueEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:ae93f816fc67eb16437dbd9f6f6a485e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of an analog point.  <a href="#ae93f816fc67eb16437dbd9f6f6a485e4">More...</a><br /></td></tr>
<tr class="separator:ae93f816fc67eb16437dbd9f6f6a485e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180e0d9f367171f5bfc00a9d69ccffab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a180e0d9f367171f5bfc00a9d69ccffab">GetAnalogPointCountsEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a180e0d9f367171f5bfc00a9d69ccffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current counts of an analog point.  <a href="#a180e0d9f367171f5bfc00a9d69ccffab">More...</a><br /></td></tr>
<tr class="separator:a180e0d9f367171f5bfc00a9d69ccffab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f47447d52e7441ff4f66a9cd02c4cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a88f47447d52e7441ff4f66a9cd02c4cb">GetAnalogPointMinValueEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a88f47447d52e7441ff4f66a9cd02c4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the lowest recorded value of an analog point.  <a href="#a88f47447d52e7441ff4f66a9cd02c4cb">More...</a><br /></td></tr>
<tr class="separator:a88f47447d52e7441ff4f66a9cd02c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fa113ec866548a4db79d3f5a274e22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a98fa113ec866548a4db79d3f5a274e22">GetAnalogPointMaxValueEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a98fa113ec866548a4db79d3f5a274e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the highest recorded value of an analog point.  <a href="#a98fa113ec866548a4db79d3f5a274e22">More...</a><br /></td></tr>
<tr class="separator:a98fa113ec866548a4db79d3f5a274e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6221f2ef91376139051e7274e75833f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab6221f2ef91376139051e7274e75833f">GetAnalogPointTpoPeriodEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:ab6221f2ef91376139051e7274e75833f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an analog point's TPO period.  <a href="#ab6221f2ef91376139051e7274e75833f">More...</a><br /></td></tr>
<tr class="separator:ab6221f2ef91376139051e7274e75833f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa11d673f1b9da056551a3e7150ebda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#abaa11d673f1b9da056551a3e7150ebda">GetAnalogPointReadAreaEx</a> (int nModule, int nPoint, <a class="el" href="a00012.html">SIOMM_AnaPointReadArea</a> *pData)</td></tr>
<tr class="memdesc:abaa11d673f1b9da056551a3e7150ebda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entirety of an analog point's read area in one shot.  <a href="#abaa11d673f1b9da056551a3e7150ebda">More...</a><br /></td></tr>
<tr class="separator:abaa11d673f1b9da056551a3e7150ebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd6038943b5ad1399bbf0de12d6991"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a64dd6038943b5ad1399bbf0de12d6991">SetAnalogPointValueEx</a> (int nModule, int nPoint, float fValue)</td></tr>
<tr class="memdesc:a64dd6038943b5ad1399bbf0de12d6991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an analog point.  <a href="#a64dd6038943b5ad1399bbf0de12d6991">More...</a><br /></td></tr>
<tr class="separator:a64dd6038943b5ad1399bbf0de12d6991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810bec392f6d0339b66fb8ea4af8c68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5810bec392f6d0339b66fb8ea4af8c68">SetAnalogPointCountsEx</a> (int nModule, int nPoint, float fValue)</td></tr>
<tr class="memdesc:a5810bec392f6d0339b66fb8ea4af8c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the counts value of an analog point.  <a href="#a5810bec392f6d0339b66fb8ea4af8c68">More...</a><br /></td></tr>
<tr class="separator:a5810bec392f6d0339b66fb8ea4af8c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a347c26cac363dd5d3033c7b01d293"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a97a347c26cac363dd5d3033c7b01d293">SetAnalogPointTpoPeriodEx</a> (int nModule, int nPoint, float fValue)</td></tr>
<tr class="memdesc:a97a347c26cac363dd5d3033c7b01d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TPO period of an analog point.  <a href="#a97a347c26cac363dd5d3033c7b01d293">More...</a><br /></td></tr>
<tr class="separator:a97a347c26cac363dd5d3033c7b01d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6b09a29ee69efbed4620a155345e34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2a6b09a29ee69efbed4620a155345e34">ReadClearAnalogPointMinValueEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a2a6b09a29ee69efbed4620a155345e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the minimum value recorded on an analog point.  <a href="#a2a6b09a29ee69efbed4620a155345e34">More...</a><br /></td></tr>
<tr class="separator:a2a6b09a29ee69efbed4620a155345e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe152680b105ba7a26ad07c981e4a4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aabe152680b105ba7a26ad07c981e4a4f">ReadClearAnalogPointMaxValueEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:aabe152680b105ba7a26ad07c981e4a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the maximum value recorded on an analog point.  <a href="#aabe152680b105ba7a26ad07c981e4a4f">More...</a><br /></td></tr>
<tr class="separator:aabe152680b105ba7a26ad07c981e4a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4dd1e161c9654a810ff7e36dba7e6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8b4dd1e161c9654a810ff7e36dba7e6c">GetAnaPtValue</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a8b4dd1e161c9654a810ff7e36dba7e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of an analog point.  <a href="#a8b4dd1e161c9654a810ff7e36dba7e6c">More...</a><br /></td></tr>
<tr class="separator:a8b4dd1e161c9654a810ff7e36dba7e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b486d3bd66f08d53eb74e9a95d6ba9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a18b486d3bd66f08d53eb74e9a95d6ba9">GetAnaPtCounts</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a18b486d3bd66f08d53eb74e9a95d6ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current counts value of an analog point.  <a href="#a18b486d3bd66f08d53eb74e9a95d6ba9">More...</a><br /></td></tr>
<tr class="separator:a18b486d3bd66f08d53eb74e9a95d6ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20b0b8f3e02619d429ba742392f3474"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae20b0b8f3e02619d429ba742392f3474">GetAnaPtMinValue</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:ae20b0b8f3e02619d429ba742392f3474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the lowest recorded value of an analog point.  <a href="#ae20b0b8f3e02619d429ba742392f3474">More...</a><br /></td></tr>
<tr class="separator:ae20b0b8f3e02619d429ba742392f3474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522c1f3401633b072bdf2da5b3497449"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a522c1f3401633b072bdf2da5b3497449">GetAnaPtMaxValue</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a522c1f3401633b072bdf2da5b3497449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the highest recorded value of an analog point.  <a href="#a522c1f3401633b072bdf2da5b3497449">More...</a><br /></td></tr>
<tr class="separator:a522c1f3401633b072bdf2da5b3497449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9d37f0ae191c1ff3c6ae7fb8b54294"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ade9d37f0ae191c1ff3c6ae7fb8b54294">GetAnaPtTpoPeriod</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:ade9d37f0ae191c1ff3c6ae7fb8b54294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an analog point's TPO period.  <a href="#ade9d37f0ae191c1ff3c6ae7fb8b54294">More...</a><br /></td></tr>
<tr class="separator:ade9d37f0ae191c1ff3c6ae7fb8b54294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6fb437a1a4c97314ee43b621d98921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#adc6fb437a1a4c97314ee43b621d98921">GetAnaPtReadAreaEx</a> (int nPoint, <a class="el" href="a00012.html">SIOMM_AnaPointReadArea</a> *pData)</td></tr>
<tr class="memdesc:adc6fb437a1a4c97314ee43b621d98921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entirety of an analog point's read area in one shot.  <a href="#adc6fb437a1a4c97314ee43b621d98921">More...</a><br /></td></tr>
<tr class="separator:adc6fb437a1a4c97314ee43b621d98921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75d5424a3b52f19bd450029a1706563"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af75d5424a3b52f19bd450029a1706563">SetAnaPtValue</a> (int nPoint, float fValue)</td></tr>
<tr class="memdesc:af75d5424a3b52f19bd450029a1706563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of an analog point.  <a href="#af75d5424a3b52f19bd450029a1706563">More...</a><br /></td></tr>
<tr class="separator:af75d5424a3b52f19bd450029a1706563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4745ce84dd2ceef4a03dacb4996860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#acd4745ce84dd2ceef4a03dacb4996860">SetAnaPtCounts</a> (int nPoint, float fValue)</td></tr>
<tr class="memdesc:acd4745ce84dd2ceef4a03dacb4996860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the counts value of an analog point.  <a href="#acd4745ce84dd2ceef4a03dacb4996860">More...</a><br /></td></tr>
<tr class="separator:acd4745ce84dd2ceef4a03dacb4996860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfc837f6bfc68dd5f303fa024648015"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8bfc837f6bfc68dd5f303fa024648015">SetAnaPtTpoPeriod</a> (int nPoint, float fValue)</td></tr>
<tr class="memdesc:a8bfc837f6bfc68dd5f303fa024648015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TPO period of an analog point.  <a href="#a8bfc837f6bfc68dd5f303fa024648015">More...</a><br /></td></tr>
<tr class="separator:a8bfc837f6bfc68dd5f303fa024648015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f638cf39290a6e4a93d6ee95a71303"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a24f638cf39290a6e4a93d6ee95a71303">ReadClearAnaPtMinValue</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a24f638cf39290a6e4a93d6ee95a71303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the minimum value recorded on an analog point.  <a href="#a24f638cf39290a6e4a93d6ee95a71303">More...</a><br /></td></tr>
<tr class="separator:a24f638cf39290a6e4a93d6ee95a71303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fc800852b66d447b5ab8e570a7698f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a56fc800852b66d447b5ab8e570a7698f">ReadClearAnaPtMaxValue</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:a56fc800852b66d447b5ab8e570a7698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and clear the maximum value recorded on an analog point.  <a href="#a56fc800852b66d447b5ab8e570a7698f">More...</a><br /></td></tr>
<tr class="separator:a56fc800852b66d447b5ab8e570a7698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6016c52856f4bf258efa72c042da74d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a6016c52856f4bf258efa72c042da74d3">GetAnaBankValuesEx</a> (<a class="el" href="a00010.html">SIOMM_AnaBank</a> *pBankData)</td></tr>
<tr class="memdesc:a6016c52856f4bf258efa72c042da74d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of all 64 possible analog points at once.  <a href="#a6016c52856f4bf258efa72c042da74d3">More...</a><br /></td></tr>
<tr class="separator:a6016c52856f4bf258efa72c042da74d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7beecd966a30fafe3df351f97f12b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aab7beecd966a30fafe3df351f97f12b9">GetAnaBankCountsEx</a> (<a class="el" href="a00010.html">SIOMM_AnaBank</a> *pBankData)</td></tr>
<tr class="memdesc:aab7beecd966a30fafe3df351f97f12b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the counts value of all 64 possible analog points at once.  <a href="#aab7beecd966a30fafe3df351f97f12b9">More...</a><br /></td></tr>
<tr class="separator:aab7beecd966a30fafe3df351f97f12b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38c58e736319261a1d243752719b6fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac38c58e736319261a1d243752719b6fd">GetAnaBankMinValuesEx</a> (<a class="el" href="a00010.html">SIOMM_AnaBank</a> *pBankData)</td></tr>
<tr class="memdesc:ac38c58e736319261a1d243752719b6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the minimum recorded value of all 64 possible analog points at once.  <a href="#ac38c58e736319261a1d243752719b6fd">More...</a><br /></td></tr>
<tr class="separator:ac38c58e736319261a1d243752719b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568c0e1c9124186ac45ce817c2de8cb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a568c0e1c9124186ac45ce817c2de8cb8">GetAnaBankMaxValuesEx</a> (<a class="el" href="a00010.html">SIOMM_AnaBank</a> *pBankData)</td></tr>
<tr class="memdesc:a568c0e1c9124186ac45ce817c2de8cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the maximum recorded value of all 64 possible analog points at once.  <a href="#a568c0e1c9124186ac45ce817c2de8cb8">More...</a><br /></td></tr>
<tr class="separator:a568c0e1c9124186ac45ce817c2de8cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc690e884febdcf819e32e5db9a954a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a1dc690e884febdcf819e32e5db9a954a">GetAnaBanksEx</a> (<a class="el" href="a00011.html">SIOMM_AnaBanks</a> *pBankData)</td></tr>
<tr class="memdesc:a1dc690e884febdcf819e32e5db9a954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire analog bank at once.  <a href="#a1dc690e884febdcf819e32e5db9a954a">More...</a><br /></td></tr>
<tr class="separator:a1dc690e884febdcf819e32e5db9a954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62941bda0673a8e404dd592d9521883d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a62941bda0673a8e404dd592d9521883d">SetAnaBankValuesEx</a> (<a class="el" href="a00010.html">SIOMM_AnaBank</a> BankData)</td></tr>
<tr class="memdesc:a62941bda0673a8e404dd592d9521883d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all analog point values at once.  <a href="#a62941bda0673a8e404dd592d9521883d">More...</a><br /></td></tr>
<tr class="separator:a62941bda0673a8e404dd592d9521883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b956183ec7734e5b6b8e1d616debab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a57b956183ec7734e5b6b8e1d616debab">SetAnaBankCountsEx</a> (<a class="el" href="a00010.html">SIOMM_AnaBank</a> BankData)</td></tr>
<tr class="memdesc:a57b956183ec7734e5b6b8e1d616debab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all analog point counter values at once.  <a href="#a57b956183ec7734e5b6b8e1d616debab">More...</a><br /></td></tr>
<tr class="separator:a57b956183ec7734e5b6b8e1d616debab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37fcf672040da34e07c1d7bd4f12024"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af37fcf672040da34e07c1d7bd4f12024">CalcSetAnaPtOffset</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:af37fcf672040da34e07c1d7bd4f12024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and set an analog point's offset.  <a href="#af37fcf672040da34e07c1d7bd4f12024">More...</a><br /></td></tr>
<tr class="separator:af37fcf672040da34e07c1d7bd4f12024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83761470bd501038deb5ebdba2775c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac83761470bd501038deb5ebdba2775c9">CalcSetAnaPtGain</a> (int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:ac83761470bd501038deb5ebdba2775c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and set an analog point's gain.  <a href="#ac83761470bd501038deb5ebdba2775c9">More...</a><br /></td></tr>
<tr class="separator:ac83761470bd501038deb5ebdba2775c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144e356e1a1bf5428115762a288ea8e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a144e356e1a1bf5428115762a288ea8e2">SetPidLoopConfigurationEx</a> (int nPid, <a class="el" href="a00026.html">SIOMM_PidLoopConfigArea</a> Data)</td></tr>
<tr class="memdesc:a144e356e1a1bf5428115762a288ea8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a PID (proportional/integral/derivative) loop to run on the I/O unit.  <a href="#a144e356e1a1bf5428115762a288ea8e2">More...</a><br /></td></tr>
<tr class="separator:a144e356e1a1bf5428115762a288ea8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13228f2fdc8e1909fd40786a26de56cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13228f2fdc8e1909fd40786a26de56cf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetTpoConfigurationEx</b> (int nTpo, <a class="el" href="a00047.html">SIOMM_TpoConfigArea</a> Data)</td></tr>
<tr class="separator:a13228f2fdc8e1909fd40786a26de56cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb906a68b62b8d6e9d88b30a5fba0ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eb906a68b62b8d6e9d88b30a5fba0ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetTpoConfigurationEx</b> (int nTpo, <a class="el" href="a00047.html">SIOMM_TpoConfigArea</a> *pTpoData)</td></tr>
<tr class="separator:a0eb906a68b62b8d6e9d88b30a5fba0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f418c2ee601cdbc685eb8a36a06880"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a98f418c2ee601cdbc685eb8a36a06880">SetEventMsgConfigurationEx</a> (int nMsg, <a class="el" href="a00023.html">SIOMM_EventMsgConfigArea</a> Data)</td></tr>
<tr class="memdesc:a98f418c2ee601cdbc685eb8a36a06880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure an event message.  <a href="#a98f418c2ee601cdbc685eb8a36a06880">More...</a><br /></td></tr>
<tr class="separator:a98f418c2ee601cdbc685eb8a36a06880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a098b3777c5263480dd8ebdbf42119"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac6a098b3777c5263480dd8ebdbf42119">SetDigitalEventConfigurationEx</a> (int nEvent, <a class="el" href="a00018.html">SIOMM_DigitalEventConfigArea</a> Data)</td></tr>
<tr class="memdesc:ac6a098b3777c5263480dd8ebdbf42119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure digital events and reactions.  <a href="#ac6a098b3777c5263480dd8ebdbf42119">More...</a><br /></td></tr>
<tr class="separator:ac6a098b3777c5263480dd8ebdbf42119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28305893512b05b35169ea8197d18445"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a28305893512b05b35169ea8197d18445">SetAlarmEventConfigurationEx</a> (int nEvent, <a class="el" href="a00009.html">SIOMM_AlarmEventConfigArea</a> Data)</td></tr>
<tr class="memdesc:a28305893512b05b35169ea8197d18445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure reactions in response to alarms.  <a href="#a28305893512b05b35169ea8197d18445">More...</a><br /></td></tr>
<tr class="separator:a28305893512b05b35169ea8197d18445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780b0c82ce26a9c7f28c9b0a54cee33a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a780b0c82ce26a9c7f28c9b0a54cee33a">SetSerialEventConfigurationEx</a> (int nEvent, <a class="el" href="a00036.html">SIOMM_SerialEventConfigArea</a> Data)</td></tr>
<tr class="memdesc:a780b0c82ce26a9c7f28c9b0a54cee33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure reactions in response to serial events.  <a href="#a780b0c82ce26a9c7f28c9b0a54cee33a">More...</a><br /></td></tr>
<tr class="separator:a780b0c82ce26a9c7f28c9b0a54cee33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d7ee448d09dd63a5a9fc1ddd22b942"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a57d7ee448d09dd63a5a9fc1ddd22b942">SetTimerEventConfigurationEx</a> (int nEvent, <a class="el" href="a00046.html">SIOMM_TimerEventConfigArea</a> Data)</td></tr>
<tr class="memdesc:a57d7ee448d09dd63a5a9fc1ddd22b942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a timer event.  <a href="#a57d7ee448d09dd63a5a9fc1ddd22b942">More...</a><br /></td></tr>
<tr class="separator:a57d7ee448d09dd63a5a9fc1ddd22b942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86d4c3e86b268230c6083df81b48d31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac86d4c3e86b268230c6083df81b48d31">GetStreamConfiguration</a> (int *pnOnFlag, int *pnIntervalMS, int *pnPort, int *pnIoMirroringEnabled, int *pnStartAddress, int *pnDataSize)</td></tr>
<tr class="memdesc:ac86d4c3e86b268230c6083df81b48d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the device's current streaming configuration.  <a href="#ac86d4c3e86b268230c6083df81b48d31">More...</a><br /></td></tr>
<tr class="separator:ac86d4c3e86b268230c6083df81b48d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac021826c3feb30b18c1f5ec554636d2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac021826c3feb30b18c1f5ec554636d2d">SetStreamConfiguration</a> (int nOnFlag, int nIntervalMS, int nPort, int nIoMirroringEnabled, int nStartAddress, int nDataSize)</td></tr>
<tr class="memdesc:ac021826c3feb30b18c1f5ec554636d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IO units current streaming configuration.  <a href="#ac021826c3feb30b18c1f5ec554636d2d">More...</a><br /></td></tr>
<tr class="separator:ac021826c3feb30b18c1f5ec554636d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f67d946ea41c089a04697185b7667f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a56f67d946ea41c089a04697185b7667f">GetStreamTarget</a> (int nTarget, int *pnIpAddressArg)</td></tr>
<tr class="memdesc:a56f67d946ea41c089a04697185b7667f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the IP address of a streaming target.  <a href="#a56f67d946ea41c089a04697185b7667f">More...</a><br /></td></tr>
<tr class="separator:a56f67d946ea41c089a04697185b7667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550f970cf36948e5ead1f45652721166"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a550f970cf36948e5ead1f45652721166">SetStreamTarget</a> (int nTarget, char *pchIpAddressArg)</td></tr>
<tr class="memdesc:a550f970cf36948e5ead1f45652721166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IP address for a streaming target.  <a href="#a550f970cf36948e5ead1f45652721166">More...</a><br /></td></tr>
<tr class="separator:a550f970cf36948e5ead1f45652721166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b112a7a34c95d60aa98272344331a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a50b112a7a34c95d60aa98272344331a3">GetStreamReadAreaEx</a> (<a class="el" href="a00045.html">SIOMM_StreamStandardBlock</a> *pStreamData)</td></tr>
<tr class="memdesc:a50b112a7a34c95d60aa98272344331a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the streaming data area of the I/O units memory map.  <a href="#a50b112a7a34c95d60aa98272344331a3">More...</a><br /></td></tr>
<tr class="separator:a50b112a7a34c95d60aa98272344331a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09136e78022086c5a690a628cdb13f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae09136e78022086c5a690a628cdb13f8">GetScratchPadBitArea</a> (int *pnBits63to32, int *pnBits31to0)</td></tr>
<tr class="memdesc:ae09136e78022086c5a690a628cdb13f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the I/O unit's scratchpad bits area.  <a href="#ae09136e78022086c5a690a628cdb13f8">More...</a><br /></td></tr>
<tr class="separator:ae09136e78022086c5a690a628cdb13f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af461662178bb18fcdb9a4ba7d24cedf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af461662178bb18fcdb9a4ba7d24cedf1">SetScratchPadBitArea</a> (int nBits63to32, int nBits31to0)</td></tr>
<tr class="memdesc:af461662178bb18fcdb9a4ba7d24cedf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I/O unit's scratchpad bits area.  <a href="#af461662178bb18fcdb9a4ba7d24cedf1">More...</a><br /></td></tr>
<tr class="separator:af461662178bb18fcdb9a4ba7d24cedf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c697c8eea8250f2eac536d2e5ca782"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a69c697c8eea8250f2eac536d2e5ca782">SetScratchPadBitAreaMask</a> (int nOnMask63to32, int nOnMask31to0, int nOffMask63to32, int nOffMask31to0)</td></tr>
<tr class="memdesc:a69c697c8eea8250f2eac536d2e5ca782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I/O unit's scratchpad area.  <a href="#a69c697c8eea8250f2eac536d2e5ca782">More...</a><br /></td></tr>
<tr class="separator:a69c697c8eea8250f2eac536d2e5ca782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef49d1268fa5ff850ae6e4e0bf21411"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2ef49d1268fa5ff850ae6e4e0bf21411">GetScratchPadIntegerArea</a> (int nStartIndex, int nLength, int *pnData)</td></tr>
<tr class="memdesc:a2ef49d1268fa5ff850ae6e4e0bf21411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the I/O unit's integer scratch pad area.  <a href="#a2ef49d1268fa5ff850ae6e4e0bf21411">More...</a><br /></td></tr>
<tr class="separator:a2ef49d1268fa5ff850ae6e4e0bf21411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d6b0ddc17af9ff0067bc95e2794001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a04d6b0ddc17af9ff0067bc95e2794001">SetScratchPadIntegerArea</a> (int nStartIndex, int nLength, int *pnData)</td></tr>
<tr class="memdesc:a04d6b0ddc17af9ff0067bc95e2794001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the I/O unit's integer scratch pad area.  <a href="#a04d6b0ddc17af9ff0067bc95e2794001">More...</a><br /></td></tr>
<tr class="separator:a04d6b0ddc17af9ff0067bc95e2794001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe5ee9c6c9cffe73e598f37107cbf58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#adfe5ee9c6c9cffe73e598f37107cbf58">GetScratchPadFloatArea</a> (int nStartIndex, int nLength, float *pfData)</td></tr>
<tr class="memdesc:adfe5ee9c6c9cffe73e598f37107cbf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the I/O unit's float scratch pad area.  <a href="#adfe5ee9c6c9cffe73e598f37107cbf58">More...</a><br /></td></tr>
<tr class="separator:adfe5ee9c6c9cffe73e598f37107cbf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bded96663999d82e981a9542dfe0cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac3bded96663999d82e981a9542dfe0cd">SetScratchPadFloatArea</a> (int nStartIndex, int nLength, float *pfData)</td></tr>
<tr class="memdesc:ac3bded96663999d82e981a9542dfe0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the I/O unit's float scratch pad area.  <a href="#ac3bded96663999d82e981a9542dfe0cd">More...</a><br /></td></tr>
<tr class="separator:ac3bded96663999d82e981a9542dfe0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a3e1f8505d4b3217b78844895ec758"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a17a3e1f8505d4b3217b78844895ec758">GetScratchPadStringArea</a> (int nStartIndex, int nLength, <a class="el" href="a00035.html">SIOMM_ScratchPadString</a> *pStringData)</td></tr>
<tr class="memdesc:a17a3e1f8505d4b3217b78844895ec758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the I/O unit's string scratch pad area.  <a href="#a17a3e1f8505d4b3217b78844895ec758">More...</a><br /></td></tr>
<tr class="separator:a17a3e1f8505d4b3217b78844895ec758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd292d7e5ee5af67f93f0c542cfc967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aacd292d7e5ee5af67f93f0c542cfc967">SetScratchPadStringArea</a> (int nStartIndex, int nLength, <a class="el" href="a00035.html">SIOMM_ScratchPadString</a> *pStringData)</td></tr>
<tr class="memdesc:aacd292d7e5ee5af67f93f0c542cfc967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the I/O unit's string scratch pad area.  <a href="#aacd292d7e5ee5af67f93f0c542cfc967">More...</a><br /></td></tr>
<tr class="separator:aacd292d7e5ee5af67f93f0c542cfc967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032652f87fefcde879be2d8abffdfb8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a032652f87fefcde879be2d8abffdfb8e">GetScratchPadInteger64Area</a> (int nStartIndex, int nLength, int *pnData)</td></tr>
<tr class="memdesc:a032652f87fefcde879be2d8abffdfb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the I/O unit's 64-bit integer scratch pad area.  <a href="#a032652f87fefcde879be2d8abffdfb8e">More...</a><br /></td></tr>
<tr class="separator:a032652f87fefcde879be2d8abffdfb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a71425c11813d75b7a8161a5ef689e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a05a71425c11813d75b7a8161a5ef689e">SetScratchPadInteger64Area</a> (int nStartIndex, int nLength, int *pnData)</td></tr>
<tr class="memdesc:a05a71425c11813d75b7a8161a5ef689e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the I/O unit's 64-bit integer scratch pad area.  <a href="#a05a71425c11813d75b7a8161a5ef689e">More...</a><br /></td></tr>
<tr class="separator:a05a71425c11813d75b7a8161a5ef689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756c692544ae1c09f7956d342575d72c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a756c692544ae1c09f7956d342575d72c">GetDataLoggingSamplesEx</a> (int nStartIndex, int nLength, <a class="el" href="a00016.html">SIOMM_DataLogSample</a> *pDataSamples)</td></tr>
<tr class="memdesc:a756c692544ae1c09f7956d342575d72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the I/O Unit's data log.  <a href="#a756c692544ae1c09f7956d342575d72c">More...</a><br /></td></tr>
<tr class="separator:a756c692544ae1c09f7956d342575d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28e83db17c5594cdcfae9b565917929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa28e83db17c5594cdcfae9b565917929">ConfigurePoint</a> (int nModule, int nPoint, int nPointType)</td></tr>
<tr class="memdesc:aa28e83db17c5594cdcfae9b565917929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the I/O unit what kind of point is at a given location.  <a href="#aa28e83db17c5594cdcfae9b565917929">More...</a><br /></td></tr>
<tr class="separator:aa28e83db17c5594cdcfae9b565917929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fca4fff98fac62f58ebe14fb7639adf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a3fca4fff98fac62f58ebe14fb7639adf">SetPointFeatureEx</a> (int nModule, int nPoint, int nPointFeature)</td></tr>
<tr class="memdesc:a3fca4fff98fac62f58ebe14fb7639adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a point's feature.  <a href="#a3fca4fff98fac62f58ebe14fb7639adf">More...</a><br /></td></tr>
<tr class="separator:a3fca4fff98fac62f58ebe14fb7639adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa350e15d717129c1474137168856f0a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa350e15d717129c1474137168856f0a2">GetPointFeatureEx</a> (int nModule, int nPoint, int *pnPointFeature)</td></tr>
<tr class="memdesc:aa350e15d717129c1474137168856f0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point's feature enumeration.  <a href="#aa350e15d717129c1474137168856f0a2">More...</a><br /></td></tr>
<tr class="separator:aa350e15d717129c1474137168856f0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc803cfd3dd37eaabb47ba931b193fbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#abc803cfd3dd37eaabb47ba931b193fbc">GetModuleType</a> (int nModule, int nPoint, int *pnModuleType)</td></tr>
<tr class="memdesc:abc803cfd3dd37eaabb47ba931b193fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the type of a point on a given module.  <a href="#abc803cfd3dd37eaabb47ba931b193fbc">More...</a><br /></td></tr>
<tr class="separator:abc803cfd3dd37eaabb47ba931b193fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9bae9136496ebabf769fbe33955bbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0f9bae9136496ebabf769fbe33955bbd">GetPointConfigurationEx4</a> (int nModule, int nPoint, <a class="el" href="a00030.html">SIOMM_PointConfigArea4</a> *pData)</td></tr>
<tr class="memdesc:a0f9bae9136496ebabf769fbe33955bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full configuration data for a given point.  <a href="#a0f9bae9136496ebabf769fbe33955bbd">More...</a><br /></td></tr>
<tr class="separator:a0f9bae9136496ebabf769fbe33955bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5572da0f0de16f490429163c06c09619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5572da0f0de16f490429163c06c09619">GetPointGain</a> (int nModule, int nPoint, float *pfGain)</td></tr>
<tr class="memdesc:a5572da0f0de16f490429163c06c09619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current gain value of an analog point.  <a href="#a5572da0f0de16f490429163c06c09619">More...</a><br /></td></tr>
<tr class="separator:a5572da0f0de16f490429163c06c09619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c11f63153f2e0866db069f3b4abc1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a64c11f63153f2e0866db069f3b4abc1e">GetPointOffset</a> (int nModule, int nPoint, float *pfOffset)</td></tr>
<tr class="memdesc:a64c11f63153f2e0866db069f3b4abc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current offset value of an analog point.  <a href="#a64c11f63153f2e0866db069f3b4abc1e">More...</a><br /></td></tr>
<tr class="separator:a64c11f63153f2e0866db069f3b4abc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d40e6732fce3373bd7e0d200d7045f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab4d40e6732fce3373bd7e0d200d7045f">SetPointConfigurationEx4</a> (int nModule, int nPoint, <a class="el" href="a00030.html">SIOMM_PointConfigArea4</a> PtConfigData)</td></tr>
<tr class="memdesc:ab4d40e6732fce3373bd7e0d200d7045f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the full configuration data for a given point.  <a href="#ab4d40e6732fce3373bd7e0d200d7045f">More...</a><br /></td></tr>
<tr class="separator:ab4d40e6732fce3373bd7e0d200d7045f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28533a6ba654d7214814238851d4a8a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a28533a6ba654d7214814238851d4a8a7">SetPointFilterWeight</a> (int nModule, int nPoint, float fFilterWeight)</td></tr>
<tr class="memdesc:a28533a6ba654d7214814238851d4a8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an analog point's filter weight.  <a href="#a28533a6ba654d7214814238851d4a8a7">More...</a><br /></td></tr>
<tr class="separator:a28533a6ba654d7214814238851d4a8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb24c2703c196ab49cba5d054475a1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2cb24c2703c196ab49cba5d054475a1c">SetPointGain</a> (int nModule, int nPoint, float fGain)</td></tr>
<tr class="memdesc:a2cb24c2703c196ab49cba5d054475a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an analog point's gain value.  <a href="#a2cb24c2703c196ab49cba5d054475a1c">More...</a><br /></td></tr>
<tr class="separator:a2cb24c2703c196ab49cba5d054475a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec200201f3995f03ea633bbe79cf87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af4ec200201f3995f03ea633bbe79cf87">SetPointOffset</a> (int nModule, int nPoint, float fOffset)</td></tr>
<tr class="memdesc:af4ec200201f3995f03ea633bbe79cf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an analog point's offset value.  <a href="#af4ec200201f3995f03ea633bbe79cf87">More...</a><br /></td></tr>
<tr class="separator:af4ec200201f3995f03ea633bbe79cf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545e8c3eb58ead08ff87df458061ff2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a545e8c3eb58ead08ff87df458061ff2e">SetPointScale</a> (int nModule, int nPoint, float fHiScale, float fLoScale)</td></tr>
<tr class="memdesc:a545e8c3eb58ead08ff87df458061ff2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scaling values for an analog point.  <a href="#a545e8c3eb58ead08ff87df458061ff2e">More...</a><br /></td></tr>
<tr class="separator:a545e8c3eb58ead08ff87df458061ff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac330577bbfad76f28b8c28ded9284d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#abac330577bbfad76f28b8c28ded9284d">SetPointWatchdog</a> (int nModule, int nPoint, float fValue, int nEnabled)</td></tr>
<tr class="memdesc:abac330577bbfad76f28b8c28ded9284d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a watchdog for a point.  <a href="#abac330577bbfad76f28b8c28ded9284d">More...</a><br /></td></tr>
<tr class="separator:abac330577bbfad76f28b8c28ded9284d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7120935e6a23dc4bf75815de92f0820"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae7120935e6a23dc4bf75815de92f0820">SetPointName</a> (int nModule, int nPoint, char *pchPointName)</td></tr>
<tr class="memdesc:ae7120935e6a23dc4bf75815de92f0820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user-friendly name for a point.  <a href="#ae7120935e6a23dc4bf75815de92f0820">More...</a><br /></td></tr>
<tr class="separator:ae7120935e6a23dc4bf75815de92f0820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb94394c28d63d1ae9442d33797a76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a97eb94394c28d63d1ae9442d33797a76">GetDigitalPointReadAreaEx</a> (int nModule, int nPoint, <a class="el" href="a00019.html">SIOMM_DigPointReadArea</a> *pData)</td></tr>
<tr class="memdesc:a97eb94394c28d63d1ae9442d33797a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the read area for a high density digital point.  <a href="#a97eb94394c28d63d1ae9442d33797a76">More...</a><br /></td></tr>
<tr class="separator:a97eb94394c28d63d1ae9442d33797a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61e6d4ffc3efb343c635eec61dd58b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#af61e6d4ffc3efb343c635eec61dd58b4">CalcSetAnalogPointOffsetEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:af61e6d4ffc3efb343c635eec61dd58b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and set an analog point's offset.  <a href="#af61e6d4ffc3efb343c635eec61dd58b4">More...</a><br /></td></tr>
<tr class="separator:af61e6d4ffc3efb343c635eec61dd58b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0db297c64f42ea9cc08d86cd24a1d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa0db297c64f42ea9cc08d86cd24a1d0a">CalcSetAnalogPointGainEx</a> (int nModule, int nPoint, float *pfValue)</td></tr>
<tr class="memdesc:aa0db297c64f42ea9cc08d86cd24a1d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and set an analog point's gain.  <a href="#aa0db297c64f42ea9cc08d86cd24a1d0a">More...</a><br /></td></tr>
<tr class="separator:aa0db297c64f42ea9cc08d86cd24a1d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6746ba7f39a87bddf0184988108d85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5e6746ba7f39a87bddf0184988108d85">SetAnalogOutputClamp</a> (int nModule, int nPoint, float fLowClamp, float fHighClamp)</td></tr>
<tr class="memdesc:a5e6746ba7f39a87bddf0184988108d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set clamping values for an analog point.  <a href="#a5e6746ba7f39a87bddf0184988108d85">More...</a><br /></td></tr>
<tr class="separator:a5e6746ba7f39a87bddf0184988108d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e83f7821588a1d31b46d83d99387334"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a4e83f7821588a1d31b46d83d99387334">GetAnalogOutputClamp</a> (int nModule, int nPoint, float *pfLowClamp, float *pfHighClamp)</td></tr>
<tr class="memdesc:a4e83f7821588a1d31b46d83d99387334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve clamping values for an analog point.  <a href="#a4e83f7821588a1d31b46d83d99387334">More...</a><br /></td></tr>
<tr class="separator:a4e83f7821588a1d31b46d83d99387334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a8711913a46c63be8b3fdd79863f88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a09a8711913a46c63be8b3fdd79863f88">SetAnalogOutputClamp</a> (int nPoint, float fLowClamp, float fHighClamp)</td></tr>
<tr class="memdesc:a09a8711913a46c63be8b3fdd79863f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set clamping values for an analog point.  <a href="#a09a8711913a46c63be8b3fdd79863f88">More...</a><br /></td></tr>
<tr class="separator:a09a8711913a46c63be8b3fdd79863f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b50dcc3a2aaa4a2fdf461b81d8cd58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae4b50dcc3a2aaa4a2fdf461b81d8cd58">GetAnalogOutputClamp</a> (int nPoint, float *pfLowClamp, float *pfHighClamp)</td></tr>
<tr class="memdesc:ae4b50dcc3a2aaa4a2fdf461b81d8cd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve clamping values for an analog point.  <a href="#ae4b50dcc3a2aaa4a2fdf461b81d8cd58">More...</a><br /></td></tr>
<tr class="separator:ae4b50dcc3a2aaa4a2fdf461b81d8cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff4d0d2b84017786369dea79c6a9a39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0ff4d0d2b84017786369dea79c6a9a39">EpicGetDigitalChannel</a> (int nModuleIndex, int nChannelIndex, <a class="el" href="a00021.html">SIOMM_EpicDigitalChannelRead</a> *pstructEpicDigital)</td></tr>
<tr class="memdesc:a0ff4d0d2b84017786369dea79c6a9a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a EPIC generation discrete channel.  <a href="#a0ff4d0d2b84017786369dea79c6a9a39">More...</a><br /></td></tr>
<tr class="separator:a0ff4d0d2b84017786369dea79c6a9a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda99817c570645ab6b3ff046c73a177"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#acda99817c570645ab6b3ff046c73a177">EpicGetDigitalPacked</a> (<a class="el" href="a00022.html">SIOMM_EpicPackedDigitalRead</a> *pstructEpicPackedDigital)</td></tr>
<tr class="memdesc:acda99817c570645ab6b3ff046c73a177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a EPIC digital packed area.  <a href="#acda99817c570645ab6b3ff046c73a177">More...</a><br /></td></tr>
<tr class="separator:acda99817c570645ab6b3ff046c73a177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7116cc10728b341473be23683d8826fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a7116cc10728b341473be23683d8826fd">EpicGetAnalogChannel</a> (int nModuleIndex, int nChannelIndex, <a class="el" href="a00020.html">SIOMM_EpicAnalogChannelRead</a> *pstructEpicAnalog)</td></tr>
<tr class="memdesc:a7116cc10728b341473be23683d8826fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a EPIC generation analog channel.  <a href="#a7116cc10728b341473be23683d8826fd">More...</a><br /></td></tr>
<tr class="separator:a7116cc10728b341473be23683d8826fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06b076b9d657c6de6a62667042e6dcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae06b076b9d657c6de6a62667042e6dcb">EpicGetModuleQuality</a> (<a class="el" href="a00024.html">SIOMM_ModuleQuality</a> *pstructModuleQuality)</td></tr>
<tr class="memdesc:ae06b076b9d657c6de6a62667042e6dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the quality status of all EPIC I/O modules.  <a href="#ae06b076b9d657c6de6a62667042e6dcb">More...</a><br /></td></tr>
<tr class="separator:ae06b076b9d657c6de6a62667042e6dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac670b65934c148dd649c2a56cf393590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac670b65934c148dd649c2a56cf393590">EpicGetChannelQuality</a> (int nModuleIndex, <a class="el" href="a00013.html">SIOMM_ChannelQuality</a> *pstructChannelQuality)</td></tr>
<tr class="memdesc:ac670b65934c148dd649c2a56cf393590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the quality status of a module's channels.  <a href="#ac670b65934c148dd649c2a56cf393590">More...</a><br /></td></tr>
<tr class="separator:ac670b65934c148dd649c2a56cf393590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ed62c078c2b423d0ec29d02c366070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a56ed62c078c2b423d0ec29d02c366070">GetCustomAreaAddresses</a> (int nStartIndex, int nLength, <a class="el" href="a00014.html">SIOMM_CustomAreaAddresses</a> *pstructCustomAddresses)</td></tr>
<tr class="memdesc:a56ed62c078c2b423d0ec29d02c366070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read custom area addresses.  <a href="#a56ed62c078c2b423d0ec29d02c366070">More...</a><br /></td></tr>
<tr class="separator:a56ed62c078c2b423d0ec29d02c366070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329831db32d1b3d0437065602328911c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a329831db32d1b3d0437065602328911c">SetCustomAreaAddresses</a> (int nStartIndex, int nLength, const <a class="el" href="a00014.html">SIOMM_CustomAreaAddresses</a> *pstructCustomAddresses)</td></tr>
<tr class="memdesc:a329831db32d1b3d0437065602328911c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write custom area addresses.  <a href="#a329831db32d1b3d0437065602328911c">More...</a><br /></td></tr>
<tr class="separator:a329831db32d1b3d0437065602328911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22685e34e6bbe99af8f1793b76694d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5e22685e34e6bbe99af8f1793b76694d">GetCustomAreaData</a> (int nStartIndex, int nLength, <a class="el" href="a00015.html">SIOMM_CustomAreaData</a> *pstructCustomData)</td></tr>
<tr class="memdesc:a5e22685e34e6bbe99af8f1793b76694d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read custom area data.  <a href="#a5e22685e34e6bbe99af8f1793b76694d">More...</a><br /></td></tr>
<tr class="separator:a5e22685e34e6bbe99af8f1793b76694d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44bb13ffe012a8d690782b1ce77cf1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ad44bb13ffe012a8d690782b1ce77cf1e">SetCustomAreaData</a> (int nStartIndex, int nLength, const <a class="el" href="a00015.html">SIOMM_CustomAreaData</a> *pstructCustomData)</td></tr>
<tr class="memdesc:ad44bb13ffe012a8d690782b1ce77cf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write custom area data.  <a href="#ad44bb13ffe012a8d690782b1ce77cf1e">More...</a><br /></td></tr>
<tr class="separator:ad44bb13ffe012a8d690782b1ce77cf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819e2e932c403f53fa2842946ae8f808"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a819e2e932c403f53fa2842946ae8f808">WriteBytes</a> (uint32_t dwOptoMMPAddress, int nLength, const uint8_t *pbyary)</td></tr>
<tr class="memdesc:a819e2e932c403f53fa2842946ae8f808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to memory map.  <a href="#a819e2e932c403f53fa2842946ae8f808">More...</a><br /></td></tr>
<tr class="separator:a819e2e932c403f53fa2842946ae8f808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be465216478a7304d855d75805669fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a4be465216478a7304d855d75805669fb">ReadBytes</a> (uint32_t dwOptoMMPAddress, int nLength, uint8_t *pbyary)</td></tr>
<tr class="memdesc:a4be465216478a7304d855d75805669fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from memory map.  <a href="#a4be465216478a7304d855d75805669fb">More...</a><br /></td></tr>
<tr class="separator:a4be465216478a7304d855d75805669fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9cfa62e8f73b1001052a70a4855050d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cfa62e8f73b1001052a70a4855050d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>OpenSockets</b> (const char *pchIpAddressArg, int nPort, int nOpenTimeOutMS)</td></tr>
<tr class="separator:a9cfa62e8f73b1001052a70a4855050d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab07dc1e551a26ffb4d62b91f742a2ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab07dc1e551a26ffb4d62b91f742a2ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CloseSockets</b> ()</td></tr>
<tr class="separator:aab07dc1e551a26ffb4d62b91f742a2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04dc3fda44a2535a288105d1dfa2056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af04dc3fda44a2535a288105d1dfa2056"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetBitmask64</b> (uint32_t dwDestOffset, int *pnPts63to32, int *pnPts31to0)</td></tr>
<tr class="separator:af04dc3fda44a2535a288105d1dfa2056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f0df40550cc34a688fbf47f0a00b93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f0df40550cc34a688fbf47f0a00b93"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetBitmask64</b> (uint32_t dwDestOffset, int nPts63to32, int nPts31to0)</td></tr>
<tr class="separator:ac0f0df40550cc34a688fbf47f0a00b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497c8ce871b0d4fb91efaf3bc948f16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac497c8ce871b0d4fb91efaf3bc948f16"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetAnaBank</b> (uint32_t dwDestOffset, <a class="el" href="a00010.html">SIOMM_AnaBank</a> *pBankData)</td></tr>
<tr class="separator:ac497c8ce871b0d4fb91efaf3bc948f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af2d2e0547c8f85a0552e8b3ac5a2dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3af2d2e0547c8f85a0552e8b3ac5a2dc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SetAnaBank</b> (uint32_t dwDestOffset, <a class="el" href="a00010.html">SIOMM_AnaBank</a> BankData)</td></tr>
<tr class="separator:a3af2d2e0547c8f85a0552e8b3ac5a2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746d95de9c817a63a2ccee6c03711b1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746d95de9c817a63a2ccee6c03711b1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateTransactionLabel</b> ()</td></tr>
<tr class="separator:a746d95de9c817a63a2ccee6c03711b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1eab93a0e7fd71652516743e0d7d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bf1eab93a0e7fd71652516743e0d7d2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetTickCount</b> ()</td></tr>
<tr class="separator:a1bf1eab93a0e7fd71652516743e0d7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af9a94fe98ced596d763291f52d3e5289"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9a94fe98ced596d763291f52d3e5289"></a>
SOCKET&#160;</td><td class="memItemRight" valign="bottom"><b>m_Socket</b></td></tr>
<tr class="separator:af9a94fe98ced596d763291f52d3e5289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e900124daf1feac1dac0404bbd6cb76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e900124daf1feac1dac0404bbd6cb76"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_SocketAddrLength</b></td></tr>
<tr class="separator:a8e900124daf1feac1dac0404bbd6cb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b644e379d85fc06a94db7a59c80249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1b644e379d85fc06a94db7a59c80249"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_nConnectionType</b></td></tr>
<tr class="separator:ab1b644e379d85fc06a94db7a59c80249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871cd7ce269fcf4d949d19f4fe8e4a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac871cd7ce269fcf4d949d19f4fe8e4a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_serialHandle</b></td></tr>
<tr class="separator:ac871cd7ce269fcf4d949d19f4fe8e4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f3037e7dfef3a4b1d57b9205dfe9f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62f3037e7dfef3a4b1d57b9205dfe9f8"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_serialAddress</b></td></tr>
<tr class="separator:a62f3037e7dfef3a4b1d57b9205dfe9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127db336c2da3d851324b248e9a029ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a127db336c2da3d851324b248e9a029ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_serialBaudRate</b></td></tr>
<tr class="separator:a127db336c2da3d851324b248e9a029ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c3ef4a165025acf5d43cb0b30f052b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c3ef4a165025acf5d43cb0b30f052b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_serialPort</b></td></tr>
<tr class="separator:a73c3ef4a165025acf5d43cb0b30f052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a74bde4f6d890b73f01e6da3120cdd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a74bde4f6d890b73f01e6da3120cdd4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_serialTwoWire</b></td></tr>
<tr class="separator:a2a74bde4f6d890b73f01e6da3120cdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddf3171dcf767db0ea4656fc59b9e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ddf3171dcf767db0ea4656fc59b9e00"></a>
ConnectionMethod&#160;</td><td class="memItemRight" valign="bottom"><b>m_method</b></td></tr>
<tr class="separator:a6ddf3171dcf767db0ea4656fc59b9e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bfba7345d9dc2ef771c1cce96b06e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9bfba7345d9dc2ef771c1cce96b06e3"></a>
timeval&#160;</td><td class="memItemRight" valign="bottom"><b>m_tvTimeOut</b></td></tr>
<tr class="separator:ad9bfba7345d9dc2ef771c1cce96b06e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1cacbc04f7a8f077f0fd07e6b1eebf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f1cacbc04f7a8f077f0fd07e6b1eebf"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_nTimeOutMS</b></td></tr>
<tr class="separator:a5f1cacbc04f7a8f077f0fd07e6b1eebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a205e3045b4e973bfa6ec1037261fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45a205e3045b4e973bfa6ec1037261fd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_nOpenTimeOutMS</b></td></tr>
<tr class="separator:a45a205e3045b4e973bfa6ec1037261fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b24550bb769e75b679b288e2b95eb10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b24550bb769e75b679b288e2b95eb10"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_nOpenTime</b></td></tr>
<tr class="separator:a2b24550bb769e75b679b288e2b95eb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c22bee9b52a2978232e37f64bd1ab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63c22bee9b52a2978232e37f64bd1ab1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_nRetries</b></td></tr>
<tr class="separator:a63c22bee9b52a2978232e37f64bd1ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7483ef12802c87a694c69e1ac23606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb7483ef12802c87a694c69e1ac23606"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_nAutoPUCFlag</b></td></tr>
<tr class="separator:aeb7483ef12802c87a694c69e1ac23606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302f6c4e34d6c633b139561a84641e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9302f6c4e34d6c633b139561a84641e6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_byTransactionLabel</b></td></tr>
<tr class="separator:a9302f6c4e34d6c633b139561a84641e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00002.html" title="The O22SnapIoMemMap C++ class is used to communicate from a computer to an Opto 22 OptoMMP device...">O22SnapIoMemMap</a> C++ class is used to communicate from a computer to an Opto 22 OptoMMP device. </p>
<p>The basic procedure for using this class is:</p>
<ol type="1">
<li>Create an instance of the <a class="el" href="a00002.html" title="The O22SnapIoMemMap C++ class is used to communicate from a computer to an Opto 22 OptoMMP device...">O22SnapIoMemMap</a> class</li>
<li>Call <a class="el" href="a00002.html#acb26f636587ab7e13d32d8c717c30633" title="Starts an asynchronous (unblocked) connection attempt to an OptoMMP device. ">OpenEnet()</a> or <a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51" title="Starts the connection process to an OptoMMP device. ">OpenEnet2()</a> to start connecting to an I/O unit</li>
<li>Call <a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0" title="Called after OpenEnet() or OpenEnet2() to determine if the connection has completed yet...">IsOpenDone()</a> to complete the connection process</li>
<li>Call <a class="el" href="a00002.html#aa442807fa10afedac352a5e0d6e9c0cb" title="Set communication options, such as the connection&#39;s communication timeout value. ">SetCommOptions()</a> to set the desired timeout value</li>
<li>Configure the I/O (scaling, point types, ranges, baud rates, etc) using like ConfigurePt().</li>
<li>Call any of the memory map functions, such as <a class="el" href="a00002.html#a8b4dd1e161c9654a810ff7e36dba7e6c" title="Read the current value of an analog point. ">GetAnaPtValue()</a>, <a class="el" href="a00002.html#a01dbd8c01dc13791f289054dbb2a6b0d" title="Set the states of (potentially) all standard density digital points in one call. ">SetDigBankPointStates()</a>, and <a class="el" href="a00002.html#a602bcdea6e76af88f2c9cb54b00b3ab0" title="Reads a block of data from the I/O unit. ">ReadBlock()</a>, to communicate with the I/O unit. Repeat as neccessary.</li>
<li>Call <a class="el" href="a00002.html#a5146ca6f2029216d1dda70f229c266bd" title="Close the connection to the OptoMMP device. ">Close()</a> when completely fnished messaging the device or a fault occurred. Applications typically operate in a loop (step 6), regularly accessing the device. </li>
</ol>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8b9a148ad45d90734045a0b58b066e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::BuildReadBlockRequest </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyReadBlockRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byTransactionLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestinationOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a read block request packet. </p>
<p>This is an internally used utility method to build a read request. Client code isn't likely to need it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbyReadBlockRequest</td><td>User supplied pointer to a block of memory to hold the read request. Must not be NULL, must be at least 16 bytes in size. </td></tr>
    <tr><td class="paramname">byTransactionLabel</td><td>Transaction label to embed in the read request. Lets the caller identify response packets. </td></tr>
    <tr><td class="paramname">dwDestinationOffset</td><td>The target offset to read from </td></tr>
    <tr><td class="paramname">wDataLength</td><td>The amount of data to read, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR if pbyReadBlockRequest is NULL, SIOMM_OK otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a61d18ecf07b8c4eca4e3dd73dac20675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::BuildWriteBlockRequest </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyWriteBlockRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byTransactionLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestinationOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyBlockData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a write block request packet. </p>
<p>This is an internally used utility method to build a write request. Client code isn't likely to need it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbyWriteBlockRequest</td><td>User supplied pointer to a block of memory to hold the write request. Must not be NULL, must be at least 16 bytes + wDataLength in size. </td></tr>
    <tr><td class="paramname">byTransactionLabel</td><td>Transaction label to embed in the write request. Lets the caller identify response packets. </td></tr>
    <tr><td class="paramname">dwDestinationOffset</td><td>Target offset to write data to </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of the data in pbyBlockData </td></tr>
    <tr><td class="paramname">pbyBlockData</td><td>Data to be written, this is appended to the end of the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR if pbyWriteBlockRequest or pbyBlockData are NULL, SIOMM_OK otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0db297c64f42ea9cc08d86cd24a1d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::CalcSetAnalogPointGainEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and set an analog point's gain. </p>
<p>Memory-mapped I/O units with analog capability can calculate offset and gain for analog input points. Calculate offset first, and then calculate gain. See the PAC Manager User's Guide for instructions.</p>
<p>Use this method for I/O units with firmware versions 8.0 or newer. For units with firmware version 7.1 or older, use CalcSetAnaPtGain.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ac83761470bd501038deb5ebdba2775c9" title="Calculate and set an analog point&#39;s gain. ">CalcSetAnaPtGain</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Integer between 0 and 63 (inclusive) indicating which module the target point is on. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Integer between 0 and 63 (inclusive) indicating which point on the target module to target </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float holding the result from the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything worked correctly. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL, or if either nModule or nPoint are out of range. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="af61e6d4ffc3efb343c635eec61dd58b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::CalcSetAnalogPointOffsetEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and set an analog point's offset. </p>
<p>Memory-mapped I/O units with analog capability can calculate offset and gain for analog input points. Calculate offset first, and then calculate gain. See the PAC Manager User's Guide for instructions.</p>
<p>Use this method for I/O units with firmware versions 8.0 or newer. For units with firmware version 7.1 or older, use CalcSetAnaPtOffset.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#af37fcf672040da34e07c1d7bd4f12024" title="Calculate and set an analog point&#39;s offset. ">CalcSetAnaPtOffset</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Integer between 0 and 63 (inclusive) indicating which module the target point is on. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Integer between 0 and 63 (inclusive) indicating which point on the target module to target </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float holding the result from the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything worked correctly. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL, or if either nModule or nPoint are out of range. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ac83761470bd501038deb5ebdba2775c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::CalcSetAnaPtGain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and set an analog point's gain. </p>
<p>Memory-mapped I/O units with analog capability can calculate offset and gain for analog input points. Calculate offset first, and then calculate gain. See the PAC Manager Users Guide for instructions.</p>
<p>Use this method for I/O units with firmware versions 7.1 or lower. For units with firmware version 8.0 or newer, use CalcSetAnalogPointGainEx.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#aa0db297c64f42ea9cc08d86cd24a1d0a" title="Calculate and set an analog point&#39;s gain. ">CalcSetAnalogPointGainEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything worked correctly. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="af37fcf672040da34e07c1d7bd4f12024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::CalcSetAnaPtOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and set an analog point's offset. </p>
<p>Memory-mapped I/O units with analog capability can calculate offset and gain for analog input points. Calculate offset first, and then calculate gain. See the PAC Manager Users Guide for instructions.</p>
<p>Use this method for I/O units with firmware versions 7.1 or lower. For units with firmware version 8.0 or newer, use CalcSetAnalogPointOffsetEx.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#af61e6d4ffc3efb343c635eec61dd58b4" title="Calculate and set an analog point&#39;s offset. ">CalcSetAnalogPointOffsetEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything worked correctly. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a5146ca6f2029216d1dda70f229c266bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the connection to the OptoMMP device. </p>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything is OK, an error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a16d0fd4b0f948f4b289df75b041fd847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ConfigurePoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the I/O unit what kind of point is at a given location. </p>
<p>High density digital modules and analog modules are all recognized automatically by the I/O unit when it boots up. 4-channel digital outputs are not, and need to be configured before use.</p>
<p>This method is applicable to the old 64-point memory-map implementation (B3000-ENET, UIO, and SNAP-PAC when only 4-channel or less modules are used).</p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">nPointType</td><td>Point type value. A digital output is type 0x180, an input is 0x100. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aa28e83db17c5594cdcfae9b565917929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ConfigurePoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the I/O unit what kind of point is at a given location. </p>
<p>Digital inputs, high density digital modules, and analog modules are all recognized automatically by the I/O unit when it boots up. Digital outputs are not, and so need to be configured before use.</p>
<p>NOTE: This method only works with I/O units running firmware 8.0 or newer. For I/O units running older firmware, use ConfigurePoint(nPoint, nPointType)</p>
<p>See Appendix A - (Expanded) Analog &amp; Digital Point Configuration - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the point to be configured resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to configure. </td></tr>
    <tr><td class="paramname">nPointType</td><td>Point type value. A digital output is type 0x180, an input is 0x100. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a7116cc10728b341473be23683d8826fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::EpicGetAnalogChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModuleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nChannelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">SIOMM_EpicAnalogChannelRead</a> *&#160;</td>
          <td class="paramname"><em>pstructEpicAnalog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a EPIC generation analog channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModuleIndex</td><td>module index from 0 to 63. </td></tr>
    <tr><td class="paramname">nChannelIndex</td><td>module index from 0 to 63. </td></tr>
    <tr><td class="paramname">pstructEpicAnalog</td><td>pointer to a EPIC analog channel structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the read was successful. </dd>
<dd>
SIOMM_ERROR if nModuleIndex or nChannelIndex are out of range. </dd>
<dd>
Errors resulting from Readblock() such as a timeout or the TCP session was closed. </dd></dl>

</div>
</div>
<a class="anchor" id="ac670b65934c148dd649c2a56cf393590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::EpicGetChannelQuality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModuleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00013.html">SIOMM_ChannelQuality</a> *&#160;</td>
          <td class="paramname"><em>pstructChannelQuality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the quality status of a module's channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModuleIndex</td><td>module to read status. </td></tr>
    <tr><td class="paramname">pstructChannelQuality</td><td>pointer to structure to store the channel quality values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>likely communication errors or invalid memmap address (when not used with EPIC) </dd></dl>

</div>
</div>
<a class="anchor" id="a0ff4d0d2b84017786369dea79c6a9a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::EpicGetDigitalChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModuleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nChannelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00021.html">SIOMM_EpicDigitalChannelRead</a> *&#160;</td>
          <td class="paramname"><em>pstructEpicDigital</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a EPIC generation discrete channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModuleIndex</td><td>module index from 0 to 63. </td></tr>
    <tr><td class="paramname">nChannelIndex</td><td>module index from 0 to 63. </td></tr>
    <tr><td class="paramname">pstructEpicDigital</td><td>pointer to a EPIC digital channel structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the read was successful. </dd>
<dd>
SIOMM_ERROR if nModuleIndex or nChannelIndex are out of range. </dd>
<dd>
Errors resulting from Readblock() such as a timeout or the TCP session was closed. </dd></dl>

</div>
</div>
<a class="anchor" id="acda99817c570645ab6b3ff046c73a177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::EpicGetDigitalPacked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">SIOMM_EpicPackedDigitalRead</a> *&#160;</td>
          <td class="paramname"><em>pstructEpicPackedDigital</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a EPIC digital packed area. </p>
<p>Reads all digital states, on-latches, off-latches, and channel quality for every channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstructEpicPackedDigital</td><td>pointer to a EPIC packed digital channel structure, length 16 structures long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the read was successful. </dd>
<dd>
SIOMM_ERROR if nModuleIndex or nChannelIndex are out of range. </dd>
<dd>
Errors resulting from Readblock() such as a timeout or the TCP session was closed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae06b076b9d657c6de6a62667042e6dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::EpicGetModuleQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00024.html">SIOMM_ModuleQuality</a> *&#160;</td>
          <td class="paramname"><em>pstructModuleQuality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the quality status of all EPIC I/O modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstructModuleQuality</td><td>pointer to structure to store the module quality bitmasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>likely communication errors or invalid memmap address (when not used with EPIC) </dd></dl>

</div>
</div>
<a class="anchor" id="aab7beecd966a30fafe3df351f97f12b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaBankCountsEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">SIOMM_AnaBank</a> *&#160;</td>
          <td class="paramname"><em>pBankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the counts value of all 64 possible analog points at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBankData</td><td>Pointer to a <a class="el" href="a00010.html" title="Generic array of floating point values, used in SIOMM_AnaBanks. ">SIOMM_AnaBank</a> instance to hold the results of the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a568c0e1c9124186ac45ce817c2de8cb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaBankMaxValuesEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">SIOMM_AnaBank</a> *&#160;</td>
          <td class="paramname"><em>pBankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the maximum recorded value of all 64 possible analog points at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBankData</td><td>Pointer to a <a class="el" href="a00010.html" title="Generic array of floating point values, used in SIOMM_AnaBanks. ">SIOMM_AnaBank</a> instance to hold the results of the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ac38c58e736319261a1d243752719b6fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaBankMinValuesEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">SIOMM_AnaBank</a> *&#160;</td>
          <td class="paramname"><em>pBankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the minimum recorded value of all 64 possible analog points at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBankData</td><td>Pointer to a <a class="el" href="a00010.html" title="Generic array of floating point values, used in SIOMM_AnaBanks. ">SIOMM_AnaBank</a> instance to hold the results of the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc690e884febdcf819e32e5db9a954a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaBanksEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00011.html">SIOMM_AnaBanks</a> *&#160;</td>
          <td class="paramname"><em>pBankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entire analog bank at once. </p>
<p>Compatible with 4-channel (or less) analog modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBankData</td><td>Pointer to a <a class="el" href="a00011.html" title="Analog point bank read-only area See Appendix A - Analog Bank Read - Read Only in the OptoMMP Protoco...">SIOMM_AnaBanks</a> instance to hold the results of the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a6016c52856f4bf258efa72c042da74d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaBankValuesEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">SIOMM_AnaBank</a> *&#160;</td>
          <td class="paramname"><em>pBankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the value of all 64 possible analog points at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBankData</td><td>Pointer to a <a class="el" href="a00010.html" title="Generic array of floating point values, used in SIOMM_AnaBanks. ">SIOMM_AnaBank</a> instance to hold the results of the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e83f7821588a1d31b46d83d99387334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogOutputClamp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfLowClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfHighClamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve clamping values for an analog point. </p>
<p>NOTE: This method works with I/O units running firmware versions 8.0 or newer. For units with older firmware versions, use the version of GetAnalogOutputClamp without the nModule parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the point to be configured resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to configure </td></tr>
    <tr><td class="paramname">pfLowClamp</td><td>Pointer to a float to hold the lower bound clamping value </td></tr>
    <tr><td class="paramname">pfHighClamp</td><td>Pointer to a float to hold the upper bound clamping value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point configuration was read successfully </dd>
<dd>
SIOMM_ERROR if either pfLowClamp or pfHighClamp are NULL </dd>
<dd>
Errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b50dcc3a2aaa4a2fdf461b81d8cd58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogOutputClamp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfLowClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfHighClamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve clamping values for an analog point. </p>
<p>NOTE: This method works with I/O units running firmware versions older than 8.0. For units with newer firmware versions, use the version of SetAnalogOutputClamp with the nModule parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure </td></tr>
    <tr><td class="paramname">pfLowClamp</td><td>Pointer to a float to hold the lower bound clamping value </td></tr>
    <tr><td class="paramname">pfHighClamp</td><td>Pointer to a float to hold the upper bound clamping value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point configuration was read successfully </dd>
<dd>
SIOMM_ERROR if either pfLowClamp or pfHighClamp are NULL </dd>
<dd>
Errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a180e0d9f367171f5bfc00a9d69ccffab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogPointCountsEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current counts of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a98fa113ec866548a4db79d3f5a274e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogPointMaxValueEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the highest recorded value of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a88f47447d52e7441ff4f66a9cd02c4cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogPointMinValueEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the lowest recorded value of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="abaa11d673f1b9da056551a3e7150ebda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogPointReadAreaEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00012.html">SIOMM_AnaPointReadArea</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entirety of an analog point's read area in one shot. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to an instance of a <a class="el" href="a00012.html" title="Analog Point read-only area. ">SIOMM_AnaPointReadArea</a> structure to hold the results from the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6221f2ef91376139051e7274e75833f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogPointTpoPeriodEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an analog point's TPO period. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ae93f816fc67eb16437dbd9f6f6a485e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnalogPointValueEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current value of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a18b486d3bd66f08d53eb74e9a95d6ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaPtCounts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current counts value of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use GetAnalogPointCountsEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a180e0d9f367171f5bfc00a9d69ccffab" title="Read the current counts of an analog point. ">GetAnalogPointCountsEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a522c1f3401633b072bdf2da5b3497449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaPtMaxValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the highest recorded value of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use GetAnalogPointMaxValueEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a98fa113ec866548a4db79d3f5a274e22" title="Read the highest recorded value of an analog point. ">GetAnalogPointMaxValueEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ae20b0b8f3e02619d429ba742392f3474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaPtMinValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the lowest recorded value of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use GetAnalogPointMinValueEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a88f47447d52e7441ff4f66a9cd02c4cb" title="Read the lowest recorded value of an analog point. ">GetAnalogPointMinValueEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="adc6fb437a1a4c97314ee43b621d98921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaPtReadAreaEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00012.html">SIOMM_AnaPointReadArea</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entirety of an analog point's read area in one shot. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use GetAnalogPointReadAreaEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#abaa11d673f1b9da056551a3e7150ebda" title="Read the entirety of an analog point&#39;s read area in one shot. ">GetAnalogPointReadAreaEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00012.html" title="Analog Point read-only area. ">SIOMM_AnaPointReadArea</a> instance to hold the results of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ade9d37f0ae191c1ff3c6ae7fb8b54294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaPtTpoPeriod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an analog point's TPO period. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use GetAnalogPointTpoPeriodEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ab6221f2ef91376139051e7274e75833f" title="Read an analog point&#39;s TPO period. ">GetAnalogPointTpoPeriodEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b4dd1e161c9654a810ff7e36dba7e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetAnaPtValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current value of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use GetAnalogPointValueEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ae93f816fc67eb16437dbd9f6f6a485e4" title="Read the current value of an analog point. ">GetAnalogPointValueEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a71b642849a9ad27380b8ab3b8c454a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetCommTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current timeout period as set by <a class="el" href="a00002.html#aa442807fa10afedac352a5e0d6e9c0cb" title="Set communication options, such as the connection&#39;s communication timeout value. ">SetCommOptions()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>The current timeout period in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a56ed62c078c2b423d0ec29d02c366070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetCustomAreaAddresses </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00014.html">SIOMM_CustomAreaAddresses</a> *&#160;</td>
          <td class="paramname"><em>pstructCustomAddresses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read custom area addresses. </p>
<p>Available for SNAP-PAC. /param nStartIndex starting index (0 through 1023) to begin reading from. /param nLength length of the read (0 through 255). Note, do not read past index 1024. /param pstructCustomAddresses pointer to structure storing the custom area addresses from the device. /return errors related to communication faults are most likely </p>

</div>
</div>
<a class="anchor" id="a5e22685e34e6bbe99af8f1793b76694d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetCustomAreaData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00015.html">SIOMM_CustomAreaData</a> *&#160;</td>
          <td class="paramname"><em>pstructCustomData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read custom area data. </p>
<p>Available for SNAP-PAC. /param nStartIndex starting index (0 through 1023) to begin reading from. /param nLength length of the read (0 through 255). Note, do not read past index 1024. /param pstructCustomAddresses pointer to structure storing the custom area data read. /return errors related to communication faults are most likely </p>

</div>
</div>
<a class="anchor" id="a756c692544ae1c09f7956d342575d72c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDataLoggingSamplesEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00016.html">SIOMM_DataLogSample</a> *&#160;</td>
          <td class="paramname"><em>pDataSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from the I/O Unit's data log. </p>
<p>The SNAP-PAC-R Series, SNAP-PAC-EB or SNAP-PAC-SB, SNAP Ultimate, or SNAP Ethernet devices includes a feature that allows data from memory map addresses to be recorded in a log file. The data from up to 64 memory map addresses can be logged, and all logged data is recorded in one file. The log file holds up to 300 lines of data; when it is filled, new entries replace the oldest ones.</p>
<p>See Chapter 2 - Logging Data in the OptoMMP Protocol Guide for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Sample location to start reading from </td></tr>
    <tr><td class="paramname">nLength</td><td>Number of samples to read. </td></tr>
    <tr><td class="paramname">pDataSamples</td><td>Array of <a class="el" href="a00016.html">SIOMM_DataLogSample</a> instances to hold the read data. Must be sizeof(SIOMM_DataLogSample) * nLength bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pDataSamples is NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a41c21c9411825dfea24aa142a59bcf93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDateTime </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pchDateTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current date and time time from the I/O unit. </p>
<p>Times are returned in a string in the format YYYY-MM-DD HH:MM:SS:00.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pchDateTime</td><td>User supplied pointer to a string. Must not be NULL, must be at least 23 characters in length (with null byte). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pchDateTime is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ae68786a1c39121dead9e408df1d36f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigBankActCounterStates </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the active counter states of tge entire bank of standard density digital points. </p>
<p>Point active counter states are returned as a pair of 32-bit bitmask values: one bit for each of the 64 possible standard density digital points on an I/O unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnPts63to32</td><td>Pointer to an integer to return a bitmask representing points 32 through 63 </td></tr>
    <tr><td class="paramname">pnPts31to0</td><td>Pointer to an integer to return a bitmask representing points 0 through 31 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the bank was read successfully. </dd>
<dd>
SIOMM_ERROR if either parameter was NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5c47cff5f4ca1b8cd39cf435ae0baf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigBankOffLatchStates </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the off-latch states of tge entire bank of standard density digital points. </p>
<p>Point off-latch states are returned as a pair of 32-bit bitmask values: one bit for each of the 64 possible standard density digital points on an I/O unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnPts63to32</td><td>Pointer to an integer to return a bitmask representing points 32 through 63 </td></tr>
    <tr><td class="paramname">pnPts31to0</td><td>Pointer to an integer to return a bitmask representing points 0 through 31 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the bank was read successfully. </dd>
<dd>
SIOMM_ERROR if either parameter was NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fee24a811de395d3f6bad3955f3e9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigBankOnLatchStates </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the on-latch states of tge entire bank of standard density digital points. </p>
<p>Point on-latch states are returned as a pair of 32-bit bitmask values: one bit for each of the 64 possible standard density digital points on an I/O unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnPts63to32</td><td>Pointer to an integer to return a bitmask representing points 32 through 63 </td></tr>
    <tr><td class="paramname">pnPts31to0</td><td>Pointer to an integer to return a bitmask representing points 0 through 31 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the bank was read successfully. </dd>
<dd>
SIOMM_ERROR if either parameter was NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a610f37b8bb2d9f365e34b63a298057b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigBankPointStates </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the status of the entire bank of standard density digital points. </p>
<p>Point states are returned as a pair of 32-bit bitmask values: one bit for each of the 64 possible standard density digital points on an I/O unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnPts63to32</td><td>Pointer to an integer to return a bitmask representing points 32 through 63 </td></tr>
    <tr><td class="paramname">pnPts31to0</td><td>Pointer to an integer to return a bitmask representing points 0 through 31 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the bank was read successfully. </dd>
<dd>
SIOMM_ERROR if either parameter was NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a805d5053b1f98f232ba86e3330870d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigBankReadAreaEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">SIOMM_DigBankReadArea</a> *&#160;</td>
          <td class="paramname"><em>pData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entire standard density digital point bank in one shot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00017.html" title="Digital Bank read-only area. ">SIOMM_DigBankReadArea</a> instance to hold the results of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the bank was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a97eb94394c28d63d1ae9442d33797a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigitalPointReadAreaEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00019.html">SIOMM_DigPointReadArea</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the read area for a high density digital point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the point to be read resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00019.html" title="Digital Point read-only area. ">SIOMM_DigPointReadArea</a> instance to hold the results of the read operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point was read successfully </dd>
<dd>
SIOMM_ERROR if pData is NULL </dd>
<dd>
Other values possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a114a1f748d3e2f48f5432ccb4dd0ebbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigPtCounterState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active counter state of a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use GetHDDigitalPointCounterState.</p>
<dl class="section see"><dt>See also</dt><dd>GetHDDigitalPointCounterState </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the counter state (e.g. on/off) for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2f3ac39eac9abe765e75a9696210749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigPtCounts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the counters of a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use GetHDDigitalPointCounts.</p>
<dl class="section see"><dt>See also</dt><dd>GetHDDigitalPointCounters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnValue</td><td>Pointer to an integer to hold the counter value for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aefe6771952934e23144e6d524c789fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigPtOffLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the off-latch state of a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use GetHDDigitalPointOffLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a90215cf5621bfb4ccb5ad3ade132d873" title="Get the off-latch state of a high-density digital point. ">GetHDDigitalPointOffLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current off-latch state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a32f609e0078d174e27babcbb3559f424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigPtOnLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the on-latch state of a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use GetHDDigitalPointOnLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ab788546808863b74da5c37887d1b3a1d" title="Get the on-latch state of a high-density digital point. ">GetHDDigitalPointOnLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current on-latch state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="af9b9a622279dac0972e9522279b31188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigPtReadAreaEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00019.html">SIOMM_DigPointReadArea</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full state of a digital point. </p>
<p>Note: This method works only for standard density digital points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00019.html" title="Digital Point read-only area. ">SIOMM_DigPointReadArea</a> instance to hold the state of the digital point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2f264e821be1933df5c4c85cd7a6d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetDigPtState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current state of a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use GetHDDigitalPointState.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ab5d7227aa02b4ff5ae8600f1519227f6" title="Get the current state of a high-density digital point. ">GetHDDigitalPointState</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aad0945787775130de619508bfeed4c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetHDDigitalPointCounts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current counter of a high-density digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use GetDigPtCounts.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#aa2f3ac39eac9abe765e75a9696210749" title="Get the counters of a digital point. ">GetDigPtCounts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read a point's state from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pnCounts</td><td>Pointer to an integer to hold the counter value for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a90215cf5621bfb4ccb5ad3ade132d873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetHDDigitalPointOffLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the off-latch state of a high-density digital point. </p>
<p>Note: This method works only for high density digital points. High density digital points must use GetDigPtOffLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#aefe6771952934e23144e6d524c789fec" title="Get the off-latch state of a digital point. ">GetDigPtOffLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read a point's state from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current off-latch state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ab788546808863b74da5c37887d1b3a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetHDDigitalPointOnLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the on-latch state of a high-density digital point. </p>
<p>Note: This method works only for high density digital points. High density digital points must use GetDigPtOnLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a32f609e0078d174e27babcbb3559f424" title="Get the on-latch state of a digital point. ">GetDigPtOnLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read a point's state from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current on-latch state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d7227aa02b4ff5ae8600f1519227f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetHDDigitalPointState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current state of a high-density digital point. </p>
<p>Note: This method works only for high density digital points. High density digital points must use GetDigPtState.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ab2f264e821be1933df5c4c85cd7a6d03" title="Get the current state of a digital point. ">GetDigPtState</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read a point's state from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a055d17c4c7d9616d871e6fda7952f3f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetModuleType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnModuleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the point type of a given point back from the I/O unit. </p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<p>This method is applicable to the 64-point memory-map implementation (B3000-ENET, UIO, and SNAP-PAC when only 4-channel or less modules are used).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnModuleType</td><td>Pointer to an integer to return the point type for the point. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pnModuleType is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="abc803cfd3dd37eaabb47ba931b193fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetModuleType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnModuleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the type of a point on a given module. </p>
<p>NOTE: This method only works with I/O units running firmware 8.0 or newer. For I/O units running older firmware, use GetModuleType(nPoint, pnModuleType).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targetted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Which point to check the type for </td></tr>
    <tr><td class="paramname">pnModuleType</td><td>Pointer to an integer to return the point type for the point. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pnModuleType is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f9bae9136496ebabf769fbe33955bbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPointConfigurationEx4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">SIOMM_PointConfigArea4</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full configuration data for a given point. </p>
<p>See Appendix A - (Expanded) Analog &amp; Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read configuration for. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00030.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea4</a> instance. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aa350e15d717129c1474137168856f0a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPointFeatureEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPointFeature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a point's feature enumeration. </p>
<p>Works with devices with firmware version 8.0 or newer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module position of where the point resides. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point index (starting from zero) on the module. </td></tr>
    <tr><td class="paramname">nPointFeature</td><td>Feature retrieved from the point. For volatile features, this value turns to zero when complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a5572da0f0de16f490429163c06c09619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPointGain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfGain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current gain value of an analog point. </p>
<p>NOTE: This method only works with I/O units running firmware 8.0 or newer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read the gain value for </td></tr>
    <tr><td class="paramname">pfGain</td><td>Pointer to a float value to return the point's gain value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pfGain is NULL </dd>
<dd>
Other errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a64c11f63153f2e0866db069f3b4abc1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPointOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current offset value of an analog point. </p>
<p>NOTE: This method only works with I/O units running firmware 8.0 or newer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read the offset value for </td></tr>
    <tr><td class="paramname">pfOffset</td><td>Pointer to a float value to return the point's offset value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pfOffsetis NULL </dd>
<dd>
Other errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="af4f502b4c4c50f220b06ddc071c13760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPtConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00027.html">SIOMM_PointConfigArea</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full configuration data for a given point. </p>
<p>NOTE: This method is deprecated, use GetPtConfigurationEx3 instead.</p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a737d839061105368bf6c786d66064a7a" title="Read the full configuration data for a given point. ">GetPtConfigurationEx3</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00027.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea</a> instance. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a08e90aa3e05c5949558e3202cf75f789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPtConfigurationEx2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">SIOMM_PointConfigArea2</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full configuration data for a given point. </p>
<p>NOTE: This method is deprecated, use GetPtConfigurationEx3 instead.</p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a737d839061105368bf6c786d66064a7a" title="Read the full configuration data for a given point. ">GetPtConfigurationEx3</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00028.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea2</a> instance. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a737d839061105368bf6c786d66064a7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetPtConfigurationEx3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00029.html">SIOMM_PointConfigArea3</a> *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full configuration data for a given point. </p>
<p>Valid for the 64-point memory model.</p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to a <a class="el" href="a00029.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea3</a> instance. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ae09136e78022086c5a690a628cdb13f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetScratchPadBitArea </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBits63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBits31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the I/O unit's scratchpad bits area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnBits63to32</td><td>Pointer to hold bits 32-63 of the scratchpad area </td></tr>
    <tr><td class="paramname">pnBits31to0</td><td>Pointer to hold bits 0-31 of the scratchpad area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the scratchpad area was read successfully. </dd>
<dd>
SIOMM_ERROR if either argument is NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="adfe5ee9c6c9cffe73e598f37107cbf58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetScratchPadFloatArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from the I/O unit's float scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the float scratchpad location to begin reading from </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in float locations) of the data to read </td></tr>
    <tr><td class="paramname">pfData</td><td>Pointer to a user-supplied buffer to write the data read to. Must be nLength * 4 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pnData was NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a032652f87fefcde879be2d8abffdfb8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetScratchPadInteger64Area </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from the I/O unit's 64-bit integer scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the 64-bit integer scratchpad location to begin reading from </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in integer locations) of the data to read </td></tr>
    <tr><td class="paramname">pnData</td><td>Pointer to a user-supplied buffer to write the data read to. Must be nLength * 8 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pnData was NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a2ef49d1268fa5ff850ae6e4e0bf21411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetScratchPadIntegerArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from the I/O unit's integer scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the integer scratchpad location to begin reading from </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in integer locations) of the data to read </td></tr>
    <tr><td class="paramname">pnData</td><td>Pointer to a user-supplied buffer to write the data read to. Must be nLength * 4 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pnData was NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a17a3e1f8505d4b3217b78844895ec758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetScratchPadStringArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00035.html">SIOMM_ScratchPadString</a> *&#160;</td>
          <td class="paramname"><em>pStringData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from the I/O unit's string scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the string scratchpad location to begin reading from </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in string locations) of the data to read </td></tr>
    <tr><td class="paramname">pStringData</td><td>Pointer to an array of <a class="el" href="a00035.html">SIOMM_ScratchPadString</a> instances to hold the read string data. Must be sizeof(SIOMM_ScratchPadString) * nLength bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pStringData was NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="acfa67b254f1ff7e473f09e6d334245ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetSerialModuleConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSerialPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00037.html">SIOMM_SerialModuleConfigArea</a> *&#160;</td>
          <td class="paramname"><em>pConfigData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the configuration of the SNAP serial communication modules on the I/O unit. </p>
<p>See Appendix A - Serial Module Configuration - Read/Write of the Opto MMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSerialPort</td><td>Which serial port to configure. See Appendix A - Serial Module Configuration - Read/Write for how port numbers are determined. </td></tr>
    <tr><td class="paramname">pConfigData</td><td>Pointer to a <a class="el" href="a00037.html">SIOMM_SerialModuleConfigArea</a> structure instance to hold the data read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pConfigData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a34f1bc483187ff1336725b1c08001263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusBootpAlways </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBootpAlways</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the "BootP always" flag from the I/O units status area. </p>
<p>If the BootP always flag is 0, the I/O unit will send a BootP (UIO, EIO, SIO, LCE) or DHCP (E1, E2) request only when it is configured to use a static IP address of 0.0.0.0.</p>
<p>If the flag is 1, the I/O unit will send a BootP or DHCP request whenever it is turned on.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnBootpAlways</td><td>Pointer to an integer to store the returned flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the flag was read successfully. </dd>
<dd>
SIOMM_ERROR if pnInteger is NULL. </dd>
<dd>
Other errors possibly resulting from ReadQuad. </dd></dl>

</div>
</div>
<a class="anchor" id="ad765c02e9feb94244af6dd0fdf0b0e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusDegrees </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnDegrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the value of the Degrees flag in the I/O units status area. </p>
<p>A value of 0 means temperature values are returned in degrees Celsius, 1 in degrees Fahrenheit.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnDegrees</td><td>Pointer to an integer to store the returned flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the flag was read successfully. </dd>
<dd>
SIOMM_ERROR if pnInteger is NULL. </dd>
<dd>
Other errors possibly resulting from ReadQuad. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a990a80d42cbe929d112e039cae7345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusHardwareEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00038.html">SIOMM_StatusHardware</a> *&#160;</td>
          <td class="paramname"><em>pHardwareData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read hardware details from the I/O unit status area. </p>
<p>NOTE: This method has been superseded by GetStatusHardwareEx2. You should probably use that one instead.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a9eec67c150a0a381529f2398762b3710" title="Read hardware details from the I/O unit status area. ">GetStatusHardwareEx2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHardwareData</td><td>Pointer to a <a class="el" href="a00038.html">SIOMM_StatusHardware</a> structure to hold the returned hardware details. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pHardwareData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a9eec67c150a0a381529f2398762b3710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusHardwareEx2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00039.html">SIOMM_StatusHardware2</a> *&#160;</td>
          <td class="paramname"><em>pHardwareData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read hardware details from the I/O unit status area. </p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHardwareData</td><td>Pointer to a <a class="el" href="a00039.html">SIOMM_StatusHardware2</a> structure to hold the returned hardware details. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pHardwareData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eaf18948fcc3155dd74acaf5bccc120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusLastError </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnErrorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the last error code from the I/O units status area. </p>
<p>If this is the only application communicating with the OptoMMP device, this value might be meaninful. Other messaging clients may be messaging the device and thus their faults will cause this field to update.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnErrorCode</td><td>Pointer to an integer to store the returned error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the error code was read successfully. </dd>
<dd>
SIOMM_ERROR if pnInteger is NULL. </dd>
<dd>
Other errors possibly resulting from ReadQuad. </dd></dl>

</div>
</div>
<a class="anchor" id="a840e1ec36b181e4ebc4aa596b8d4f324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusNetworkEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00040.html">SIOMM_StatusNetwork</a> *&#160;</td>
          <td class="paramname"><em>pNetworkData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read current IPv4 networking details from the I/O unit status area. </p>
<p>NOTE: This method has been superseded by GetStatusNetworkEx2. You should probably use that one instead.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a444d119db2e6c44d245758875b70db1e" title="Read current networking details from the I/O units status area. ">GetStatusNetworkEx2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNetworkData</td><td>Pointer to a <a class="el" href="a00040.html">SIOMM_StatusNetwork</a> structure to hold the returned network details. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pNetworkData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a444d119db2e6c44d245758875b70db1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusNetworkEx2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00041.html">SIOMM_StatusNetwork2</a> *&#160;</td>
          <td class="paramname"><em>pNetworkData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read current networking details from the I/O units status area. </p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNetworkData</td><td>Pointer to a <a class="el" href="a00041.html">SIOMM_StatusNetwork2</a> structure to hold the returned network details. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pNetworkData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ad38d7bf6a725438ebaea59a4bb23ddcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusPUC </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPUCFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the Powerup Clear flag from the I/O units status area. </p>
<p>A Powerup Clear Flag set to 0 means everything is OK. Any other value means that a Powerup Clear is needed.</p>
<p>Normally, set the autoPUC parameter of <a class="el" href="a00002.html#acb26f636587ab7e13d32d8c717c30633" title="Starts an asynchronous (unblocked) connection attempt to an OptoMMP device. ">OpenEnet()</a> or <a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51" title="Starts the connection process to an OptoMMP device. ">OpenEnet2()</a> to true. For TCP connections you should never receive a PUC expected NACK. Only with serial and UDP (connectionless protocols) could you receive such a response.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnPUCFlag</td><td>Pointer to an integer to store the returned powerup clear flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the flag was read successfully. </dd>
<dd>
SIOMM_ERROR if pnPUCFlag is NULL. </dd>
<dd>
Other errors possibly resulting from ReadQuad. </dd></dl>

</div>
</div>
<a class="anchor" id="ac49226018653f75b56df868fdad7a4fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusVersionEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00042.html">SIOMM_StatusVersion</a> *&#160;</td>
          <td class="paramname"><em>pVersionData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read version information from the I/O unit status area. </p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVersionData</td><td>Pointer to a <a class="el" href="a00042.html">SIOMM_StatusVersion</a> structure to hold the returned version information. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pVersionData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a8963fcd5fd7223a86cd93839564ec612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusWatchdogTime </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnTimeMS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the communication watchdog time setting from the I/O units status area. </p>
<p>Returns the configured watchdog time in milliseconds. A value of 0 means watchdog is disabled.</p>
<p>See Appendix A - Status Area Read in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnTimeMS</td><td>Pointer to an integer to store the returned watchdog time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the flag was read successfully. </dd>
<dd>
SIOMM_ERROR if pnInteger is NULL. </dd>
<dd>
Other errors possibly resulting from ReadQuad. </dd></dl>

</div>
</div>
<a class="anchor" id="a44009515c1848a8a44b975972678680a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStatusWriteEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">SIOMM_StatusWrite</a> *&#160;</td>
          <td class="paramname"><em>pStatusWriteData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current contents of the Status Read/Write area of the I/O unit. </p>
<p>See Appendix A - Status Area Write in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pStatusWriteData</td><td>Pointer to a <a class="el" href="a00043.html">SIOMM_StatusWrite</a> structure to hold the returned network details. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pStatusWriteData is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ac86d4c3e86b268230c6083df81b48d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStreamConfiguration </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnOnFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnIntervalMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnIoMirroringEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the device's current streaming configuration. </p>
<p>Only some OptoMMP devices support this function.</p>
<p>Streaming allows your application to get continuous information from some OptoMMP devices without the need to continually poll it.</p>
<p>See Chapter 2 - Streaming Data in the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnOnFlag</td><td>Whether or not streaming is enabled. 0 is off, non-zero is on. </td></tr>
    <tr><td class="paramname">pnIntervalMS</td><td>Streaming interval, in milliseconds </td></tr>
    <tr><td class="paramname">pnPort</td><td>IP port number to stream to </td></tr>
    <tr><td class="paramname">pnIoMirroringEnabled</td><td>Whether I/O mirroring is enabled. 0 is off, non-zero is on. </td></tr>
    <tr><td class="paramname">pnStartAddress</td><td>Beginning address of the data being streamed </td></tr>
    <tr><td class="paramname">pnDataSize</td><td>Size of data being streamed. Maximum size is 1480 bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the streaming configuration was read successfully. </dd>
<dd>
Errors possibly resulting from a call to ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a50b112a7a34c95d60aa98272344331a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStreamReadAreaEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00045.html">SIOMM_StreamStandardBlock</a> *&#160;</td>
          <td class="paramname"><em>pStreamData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the streaming data area of the I/O units memory map. </p>
<p>Returns the current state of the I/O unit's streaming area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pStreamData</td><td>Pointer to an <a class="el" href="a00045.html">SIOMM_StreamStandardBlock</a> instance to hold the results of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the streaming data area was read successfully. </dd>
<dd>
SIOMM_ERROR if pStreamData is NULL </dd>
<dd>
Other errors possibly resulting from ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a56f67d946ea41c089a04697185b7667f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::GetStreamTarget </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnIpAddressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the IP address of a streaming target. </p>
<p>Returns the IP address of the target as a single 4-byte integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTarget</td><td>Index of the streaming target to retrieve the IP address for. (1-8) </td></tr>
    <tr><td class="paramname">pnIpAddressArg</td><td>Pointer to an integer to hold the returned address. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the IP address was read successfully </dd>
<dd>
SIOMM_ERROR if pnIpAddressArg is NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="ab91379d7151aae4e777fc3f0d761b5b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::IsOpenDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after <a class="el" href="a00002.html#acb26f636587ab7e13d32d8c717c30633" title="Starts an asynchronous (unblocked) connection attempt to an OptoMMP device. ">OpenEnet()</a> or <a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51" title="Starts the connection process to an OptoMMP device. ">OpenEnet2()</a> to determine if the connection has completed yet. </p>
<p>This method should be called repeatedly until it returns something other than SIOMM_ERROR_NOT_CONNECTED_YET.</p>
<p>If SIOMM_OK is returned, the connection process is complete and there is a connection to the I/O unit.</p>
<p>If the nAutoPUC flag in <a class="el" href="a00002.html#acb26f636587ab7e13d32d8c717c30633" title="Starts an asynchronous (unblocked) connection attempt to an OptoMMP device. ">OpenEnet()</a> or <a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51" title="Starts the connection process to an OptoMMP device. ">OpenEnet2()</a> was set to TRUE, then this method will attempt to read and clear the I/O units Powerup Clear (PUC) flag after the connection has been made.</p>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR_NOT_CONNECTED_YET if the connection process isn't complete yet. </dd>
<dd>
SIOMM_TIME_OUT if the connection process timed out. </dd>
<dd>
SIOMM_OK if the connection is complete and ready to be used. </dd>
<dd>
Or possibly another error. </dd></dl>

</div>
</div>
<a class="anchor" id="acb26f636587ab7e13d32d8c717c30633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::OpenEnet </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pchIpAddressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOpenTimeOutMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nAutoPUC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous (unblocked) connection attempt to an OptoMMP device. </p>
<p>Use the <a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0" title="Called after OpenEnet() or OpenEnet2() to determine if the connection has completed yet...">IsOpenDone()</a> method to check if the open connection is completed.</p>
<p>This method always connects via TCP. If you wish to use a UDP connection, call OpenEnet2 instead. Use TCP where network packet drops are expected.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a0b8643ce7feb741af51d0b8c30a50c51" title="Starts the connection process to an OptoMMP device. ">OpenEnet2</a> </dd>
<dd>
<a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0" title="Called after OpenEnet() or OpenEnet2() to determine if the connection has completed yet...">IsOpenDone</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pchIpAddressArg</td><td>The IPv4 address, IPV6 address or hostname of the OptoMMP device as a null terminated string. </td></tr>
    <tr><td class="paramname">nPort</td><td>The port that the Ethernet brain is listening (usually 2001) </td></tr>
    <tr><td class="paramname">nOpenTimeOutMS</td><td>Time to wait for a connection before giving up (milliseconds). The minimum timeout is 100 milliseconds. </td></tr>
    <tr><td class="paramname">nAutoPUC</td><td>If non-zero, clear the brain's Powerup Clear flag automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything is OK, an error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b8643ce7feb741af51d0b8c30a50c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::OpenEnet2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pchIpAddressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOpenTimeOutMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nAutoPUC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nConnectionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the connection process to an OptoMMP device. </p>
<p>Use the <a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0" title="Called after OpenEnet() or OpenEnet2() to determine if the connection has completed yet...">IsOpenDone()</a> method to check if the open connection is completed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0" title="Called after OpenEnet() or OpenEnet2() to determine if the connection has completed yet...">IsOpenDone</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pchIpAddressArg</td><td>The IPv4 address, IPV6 address or hostname of the OptoMMP device as a null terminated string. </td></tr>
    <tr><td class="paramname">nPort</td><td>The port that the Ethernet brain is listening (usually 2001) </td></tr>
    <tr><td class="paramname">nOpenTimeOutMS</td><td>Time to wait for a connection before giving up (milliseconds). The minimum timeout is 100 milliseconds. </td></tr>
    <tr><td class="paramname">nAutoPUC</td><td>If non-zero, clear the brain's Powerup Clear flag automatically. </td></tr>
    <tr><td class="paramname">nConnectionType</td><td>Use define SIOMM_TCP or SIOMM_UDP for a TCP or UDP connection. These values coorelate to the equivalents of SOCK_STREAM or SOCK_DGRAM (respectively). In other words, the numeric constants may change on different platforms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything is OK, an error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a416aa8c4b0f05aa72337fb6a637d8e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::OpenSerial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOpenTimeOutMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nAutoPUC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects to a serial OptoMMP device (SNAP-PAC-SB1 or SNAP-PAC-SB2). </p>
<p>There is no need to call <a class="el" href="a00002.html#ab91379d7151aae4e777fc3f0d761b5b0" title="Called after OpenEnet() or OpenEnet2() to determine if the connection has completed yet...">IsOpenDone()</a> when using this connection method: either the connection will succeed or fail to lock the serial port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPort</td><td>Port number from your PC, e.g. 3 for COM3 </td></tr>
    <tr><td class="paramname">nAddress</td><td>Address is set on the brain, e.g. 0xAD </td></tr>
    <tr><td class="paramname">nBaudRate</td><td>Also set on the brain, e.g. 230400 </td></tr>
    <tr><td class="paramname">nOpenTimeOutMS</td><td>Time to wait for a connection before giving up (milliseconds) </td></tr>
    <tr><td class="paramname">nAutoPUC</td><td>If non-zero, clear the brain's Powerup Clear flag automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if we connect, an error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ead7dc892ded3b8ba6a8a926a05ac4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::OpenSerialPassThru </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pchIpAddressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSerialPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nSerialAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSerialBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bTwoWire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOpenTimeOutMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nAutoPUC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nConnectionType</em> = <code>SIOMM_TCP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects to a serial OptoMMP device (SNAP-PAC-SB1 or SNAP-PAC-SB2) through an Ethernet controller. </p>
<p>(SNAP-PAC-S1 or SNAP-PAC-S2).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pchIpAddressArg</td><td>IP address or hostname of the Ethernet controller to connect through, as a string. </td></tr>
    <tr><td class="paramname">nPort</td><td>The port that the Ethernet controller is listening (usually 2001). </td></tr>
    <tr><td class="paramname">nConnectionType</td><td>SIOMM_TCP or SIOMM_UDP for a TCP or UDP connection. </td></tr>
    <tr><td class="paramname">nSerialPort</td><td>Port number from the controller, e.g. 1 for COM1. </td></tr>
    <tr><td class="paramname">nSerialAddress</td><td>Address is set on the brain, e.g. 0xAD </td></tr>
    <tr><td class="paramname">nSerialBaudRate</td><td>Also set on the brain, e.g. 230400 </td></tr>
    <tr><td class="paramname">bTwoWire</td><td></td></tr>
    <tr><td class="paramname">nOpenTimeOutMS</td><td>Time to wait for a connection before giving up (milliseconds) </td></tr>
    <tr><td class="paramname">nAutoPUC</td><td>If non-zero, clear the brain's Powerup Clear flag automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if connect, an error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a602bcdea6e76af88f2c9cb54b00b3ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadBlock </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a block of data from the I/O unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to read data from </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of memory to read, in bytes </td></tr>
    <tr><td class="paramname">pbyData</td><td>User supplied pointer to store data read from the brain. Must not be NULL, must be at least wDataLength bytes in size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if data was read successfully. </dd>
<dd>
SIOMM_ERROR if pbyData is NULL. </dd>
<dd>
Other errors depending on what sort of connection you're using. (Ethernet, Serial, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="a2a990793af87d1b9f423c79ff14028b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadBlockAsFloats </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a chunk of memory from the brain as an array of integers. </p>
<p>This is a wrapper for ReadBlock.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a602bcdea6e76af88f2c9cb54b00b3ab0" title="Reads a block of data from the I/O unit. ">ReadBlock</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to read data from </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of memory to read, in floats (not bytes). </td></tr>
    <tr><td class="paramname">pfData</td><td>User supplied pointer to store data read from the I/O unit. Must not be NULL, must be at least wDataLength * sizeof(float) in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if data was read successfully. </dd>
<dd>
SIOMM_ERROR if pnData is NULLL. </dd>
<dd>
Other errors depending on what sort of connection you're using. (e.g. Ethernet, Serial, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="a21afd2b6984a998275e40ee743472f18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadBlockAsIntegers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a chunk of memory from the brain as an array of integers. </p>
<p>This is a wrapper for ReadBlock.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a602bcdea6e76af88f2c9cb54b00b3ab0" title="Reads a block of data from the I/O unit. ">ReadBlock</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to read data from </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of memory to read, in integers (not bytes). </td></tr>
    <tr><td class="paramname">pnData</td><td>User supplied pointer to store data read from the I/O unit. Must not be NULL, must be at least wDataLength * sizeof(int) in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if data was read successfully. </dd>
<dd>
SIOMM_ERROR if pnData is NULLL. </dd>
<dd>
Other errors depending on what sort of connection you're using. (e.g. Ethernet, Serial, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="a4be465216478a7304d855d75805669fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwOptoMMPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from memory map. </p>
<p>/param dwOptoMMPAddress lower 32-bits of the OptoMMP address to be read. /param nLength quantity of bytes to read. /param pbyary byte array of data to store data. </p>

</div>
</div>
<a class="anchor" id="aabe152680b105ba7a26ad07c981e4a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearAnalogPointMaxValueEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the maximum value recorded on an analog point. </p>
<p>NOTE: It's safe to pass NULL for pfValue if you simply want to clear the maximum value.</p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a6b09a29ee69efbed4620a155345e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearAnalogPointMinValueEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the minimum value recorded on an analog point. </p>
<p>NOTE: It's safe to pass NULL for pfValue if you simply want to clear the minimum value.</p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a56fc800852b66d447b5ab8e570a7698f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearAnaPtMaxValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the maximum value recorded on an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use ReadClearAnalogPointMaxValueEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#aabe152680b105ba7a26ad07c981e4a4f" title="Read and clear the maximum value recorded on an analog point. ">ReadClearAnalogPointMaxValueEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL; </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a24f638cf39290a6e4a93d6ee95a71303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearAnaPtMinValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the minimum value recorded on an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use ReadClearAnalogPointMinValueEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a2a6b09a29ee69efbed4620a155345e34" title="Read and clear the minimum value recorded on an analog point. ">ReadClearAnalogPointMinValueEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pfValue</td><td>Pointer to a float to hold the result of the read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL; </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a4225e78c1b5cc5fe1bb897635b38edc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearDigPtCounts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the counts value for a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use ReadClearHDDigitalPointCounts.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a861db449d8bfda289a8bbfb3961ffd6a" title="Read and clear the counts value for a high density digital point. ">ReadClearHDDigitalPointCounts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the counter state for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e3fb6242b3ca38dfc4b25a77d15086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearDigPtOffLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the off-latch state of a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use ReadClearHDDigitalPointOffLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#aec4abd1441347c56542cf33617c578b6" title="Read and clear the off-latch value for a high density digital point. ">ReadClearHDDigitalPointOffLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current off-latch state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bae288ee86837b2d36ca4f8961fec5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearDigPtOnLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the on-latch state for a digital point. </p>
<p>Note: This method works only for standard density digital points. High density digital points must use ReadClearHDDigitalPointOnLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ab788546808863b74da5c37887d1b3a1d" title="Get the on-latch state of a high-density digital point. ">GetHDDigitalPointOnLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the current on-latch state of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnState is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a861db449d8bfda289a8bbfb3961ffd6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearHDDigitalPointCounts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the counts value for a high density digital point. </p>
<p>Note: This method works only for high density digital points. High density digital points must use ReadClearDigPtCounts.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a4225e78c1b5cc5fe1bb897635b38edc4" title="Read and clear the counts value for a digital point. ">ReadClearDigPtCounts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read and clear a point's counter from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read and clear. </td></tr>
    <tr><td class="paramname">pnCounts</td><td>Pointer to an integer to hold the counter value for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aec4abd1441347c56542cf33617c578b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearHDDigitalPointOffLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the off-latch value for a high density digital point. </p>
<p>Note: This method works only for high density digital points. High density digital points must use ReadClearDigPtOffLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#aa0e3fb6242b3ca38dfc4b25a77d15086" title="Read and clear the off-latch state of a digital point. ">ReadClearDigPtOffLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read and clear a point's off-latch state from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read and clear. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the off-latch state for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f26bf943e5500fbb23aef94abffdb31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadClearHDDigitalPointOnLatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and clear the on-latch value for a high density digital point. </p>
<p>Note: This method works only for high density digital points. High density digital points must use ReadClearDigPtOnLatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a4bae288ee86837b2d36ca4f8961fec5b" title="Read and clear the on-latch state for a digital point. ">ReadClearDigPtOnLatch</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module to read and clear a point's on-latch state from. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read and clear. </td></tr>
    <tr><td class="paramname">pnState</td><td>Pointer to an integer to hold the on-latch state for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pnValue is NULL. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="acc0b2e71e9bbbf39af67582363678d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadFloat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a float (4 bytes interpreted as a float) of data from the given offset on the brain. </p>
<p>This is a wrapper for ReadQuad.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to read data from. </td></tr>
    <tr><td class="paramname">pfValue</td><td>User supplied pointer to contain the results of the read. Must not be NULL, must be at least 1 float in length. (e.g. 4 bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR if pfValue is NULL, otherwise the result from the underlying ReadQuad call. </dd></dl>

</div>
</div>
<a class="anchor" id="ae45b610c506072bf3faaaff5ef19791e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::ReadQuad </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pdwQuadlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a quad (4 bytes) of data from the given offset on the brain. </p>
<p>This is a wrapper for ReadBlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to read data from. </td></tr>
    <tr><td class="paramname">pdwQuadlet</td><td>User supplied pointer to contain the results of the read. Must not be NULL, must be at least 4 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR if pwdQuadlet is NULL, otherwise the result from the underlying ReadBlock call. </dd></dl>

</div>
</div>
<a class="anchor" id="a28305893512b05b35169ea8197d18445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAlarmEventConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00009.html">SIOMM_AlarmEventConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure reactions in response to alarms. </p>
<p>Similar to the reactions configured in SetEventMsgConfigurationEx, reactions can be triggered in response to alarms as well.</p>
<p>See Chapter 2 - Using Alarms and Reactions in the OptoMMP Protocol Guide for details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a98f418c2ee601cdbc685eb8a36a06880" title="Configure an event message. ">SetEventMsgConfigurationEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nEvent</td><td>Integer from 0 to 63 (inclusive) identifying which alarm reaction to configure </td></tr>
    <tr><td class="paramname">Data</td><td>An SIOMM_AlarmEventConfigData instance to configure the alarm reaction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the alarm configuration was written successfully </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a57b956183ec7734e5b6b8e1d616debab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnaBankCountsEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">SIOMM_AnaBank</a>&#160;</td>
          <td class="paramname"><em>BankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write all analog point counter values at once. </p>
<p>Compatible with 4-channel (or less) analog modules. Does not work with EPIC analog points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BankData</td><td><a class="el" href="a00010.html" title="Generic array of floating point values, used in SIOMM_AnaBanks. ">SIOMM_AnaBank</a> instance holding values to be written to the analog point counters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a62941bda0673a8e404dd592d9521883d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnaBankValuesEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">SIOMM_AnaBank</a>&#160;</td>
          <td class="paramname"><em>BankData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write all analog point values at once. </p>
<p>Compatible with 4-channel (or less) analog modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BankData</td><td><a class="el" href="a00010.html" title="Generic array of floating point values, used in SIOMM_AnaBanks. ">SIOMM_AnaBank</a> instance holding values to be written to the analog points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
SIOMM_ERROR if pBankData is NULL. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e6746ba7f39a87bddf0184988108d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnalogOutputClamp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fLowClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fHighClamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set clamping values for an analog point. </p>
<p>NOTE: This method works with I/O units running firmware versions 8.0 or newer. For units with older firmware versions, use the version of SetAnalogOutputClamp without the nModule parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the point to be configured resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to configure </td></tr>
    <tr><td class="paramname">fLowClamp</td><td>Lower bound clamping value </td></tr>
    <tr><td class="paramname">fHighClamp</td><td>Upper bound clamping value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point configuration was written successfully </dd>
<dd>
Errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a09a8711913a46c63be8b3fdd79863f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnalogOutputClamp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fLowClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fHighClamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set clamping values for an analog point. </p>
<p>NOTE: This method works with I/O units running firmware versions older than 8.0. For units with newer firmware versions, use the version of SetAnalogOutputClamp with the nModule parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure </td></tr>
    <tr><td class="paramname">fLowClamp</td><td>Lower bound clamping value </td></tr>
    <tr><td class="paramname">fHighClamp</td><td>Upper bound clamping value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point configuration was written successfully </dd>
<dd>
Errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a5810bec392f6d0339b66fb8ea4af8c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnalogPointCountsEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the counts value of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set on the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a97a347c26cac363dd5d3033c7b01d293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnalogPointTpoPeriodEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the TPO period of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<p>The TPO period is set in units of time in seconds. Valid range: 0.25 to 64.0 seconds, in 0.25 steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set on the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a64dd6038943b5ad1399bbf0de12d6991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnalogPointValueEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an analog point. </p>
<p>This method uses the Expanded Analog point memory map, and is only usable on I/O units running firmware 8.0 or greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module number of the point to be read. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to read. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set on the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8a51fbb0e1c6fa904ad77290ee9baad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnaPtConfiguration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fGain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fHiScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fLoScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure an analog point. </p>
<p>This method does two things:</p><ul>
<li>Configures the point's type, the same thing that ConfigurePoint does.</li>
<li>Sets point features. See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for feature values.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">nPointType</td><td>Point type value. For analog point types, see the tables in the Configuring I/O Points section of Chapter 2 of the OptoMMP Protocol Guide. </td></tr>
    <tr><td class="paramname">fOffset</td><td>Point offsets </td></tr>
    <tr><td class="paramname">fGain</td><td>Point gains </td></tr>
    <tr><td class="paramname">fHiScale</td><td>Point high scaling factors </td></tr>
    <tr><td class="paramname">fLoScale</td><td>Point low scaling factors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point was configured successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="acd4745ce84dd2ceef4a03dacb4996860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnaPtCounts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the counts value of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use SetAnalogPointCountsEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a5810bec392f6d0339b66fb8ea4af8c68" title="Set the counts value of an analog point. ">SetAnalogPointCountsEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set on the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bfc837f6bfc68dd5f303fa024648015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnaPtTpoPeriod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the TPO period of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use SetAnalogPointTpoPeriodEx instead.</p>
<p>The TPO period is set in units of time in seconds. Valid range: 0.25 to 64.0 seconds, in 0.25 steps.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a97a347c26cac363dd5d3033c7b01d293" title="Set the TPO period of an analog point. ">SetAnalogPointTpoPeriodEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set on the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="af75d5424a3b52f19bd450029a1706563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetAnaPtValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of an analog point. </p>
<p>This method is meant to be used for I/O units running a firmware version older than 8.0. If your I/O unit is running 8.0 or above, it's recommended that you use SetAnalogPointValueEx instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a64dd6038943b5ad1399bbf0de12d6991" title="Set the value of an analog point. ">SetAnalogPointValueEx</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set on the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was read successfully. </dd>
<dd>
SIOMM_ERROR if pfValue is NULL. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aa442807fa10afedac352a5e0d6e9c0cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetCommOptions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTimeOutMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nReserved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set communication options, such as the connection's communication timeout value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTimeOutMS</td><td>Timeout period for normal communications. </td></tr>
    <tr><td class="paramname">nReserved</td><td>Not used at this time. Set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything is OK, an error otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a329831db32d1b3d0437065602328911c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetCustomAreaAddresses </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html">SIOMM_CustomAreaAddresses</a> *&#160;</td>
          <td class="paramname"><em>pstructCustomAddresses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write custom area addresses. </p>
<p>Available for SNAP-PAC. /param nStartIndex starting index (0 through 1023) to begin writing to. /param nLength length of the write (0 through 255). Note, do not read past index 1024. /param pstructCustomAddresses pointer to structure storing the custom area addresses for writing. /return errors related to communication faults are most likely </p>

</div>
</div>
<a class="anchor" id="ad44bb13ffe012a8d690782b1ce77cf1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetCustomAreaData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00015.html">SIOMM_CustomAreaData</a> *&#160;</td>
          <td class="paramname"><em>pstructCustomData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write custom area data. </p>
<p>Available for SNAP-PAC. /param nStartIndex starting index (0 through 1023) to begin writing to. /param nLength length of the read (0 through 255). Note, do not write past index 1024. /param pstructCustomAddresses pointer to structure storing the data to be read. /return errors related to communication faults are most likely </p>

</div>
</div>
<a class="anchor" id="ae26ddc14ee6be41d0eb4e75f840a6527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDateTime </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pchDateTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I/O units date and time. </p>
<p>The date and time is provided as a string with format: YYYY-MM-DD HH:MM:SS:00</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pchDateTime</td><td>String providing the date and time to set on the I/O unit. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the date and time were set successfully. </dd>
<dd>
SIOMM_ERROR if pchDateTime is NULL. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aec269bf48f3f39a0cbc1e2b0031cbc1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigBankActCounterMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on the counters for a subset of all standard density digital points on at once. </p>
<p>For any digital point with a 1 in the provided mask parameters, turn that point's counter on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPts63to32</td><td>Bitmask to choose which points to set states for. (Points 32 through 63) </td></tr>
    <tr><td class="paramname">nPts31to0</td><td>Bitmask to choose which points to set states for. (Points 0 through 31) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point states were set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="af948188dc86eb4890357414a6419786e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigBankDeactCounterMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on the counters for a subset of all standard density digital points off at once. </p>
<p>For any digital point with a 1 in the provided mask parameters, turn that point's counter off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPts63to32</td><td>Bitmask to choose which points to set states for. (Points 32 through 63) </td></tr>
    <tr><td class="paramname">nPts31to0</td><td>Bitmask to choose which points to set states for. (Points 0 through 31) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point states were set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="abaa99c0ad6b78b4df1ad5ebe34b91026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigBankOffMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of a subset of all standard density digital points off at once. </p>
<p>For any digital point with a 1 in the provided mask parameters, set that point's state to off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPts63to32</td><td>Bitmask to choose which points to set states for. (Points 32 through 63) </td></tr>
    <tr><td class="paramname">nPts31to0</td><td>Bitmask to choose which points to set states for. (Points 0 through 31) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point states were set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="af123f37878a8ab1def70feaa0c01c763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigBankOnMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of a subset of all standard density digital points on at once. </p>
<p>For any digital point with a 1 in the provided mask parameters, set that point's state to on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPts63to32</td><td>Bitmask to choose which points to set states for. (Points 32 through 63) </td></tr>
    <tr><td class="paramname">nPts31to0</td><td>Bitmask to choose which points to set states for. (Points 0 through 31) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point states were set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a01dbd8c01dc13791f289054dbb2a6b0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigBankPointStates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPts31to0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMask63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMask31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the states of (potentially) all standard density digital points in one call. </p>
<p>The two mask parameters determine which points to actually set: only points with 1 values in the masks will have their states changed. The Pts values determine which states to set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPts63to32</td><td>Integer representing the states to set for points 32 through 63 </td></tr>
    <tr><td class="paramname">nPts31to0</td><td>Integer representing the states to set for points 0 through 31 </td></tr>
    <tr><td class="paramname">nMask63to32</td><td>Bitmask to choose which points to set states for. (Points 32 through 63) </td></tr>
    <tr><td class="paramname">nMask31to0</td><td>Bitmask to choose which points to set states for. (Points 0 through 31) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point states were set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6a098b3777c5263480dd8ebdbf42119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigitalEventConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">SIOMM_DigitalEventConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure digital events and reactions. </p>
<p>Note: This method works with I/O units running firmware versions 8.0 or lower.</p>
<p>In a digital event, the I/O unit monitors one or more inputs, outputs, and Scratch Pad bits for a match to a specific pattern (the event). When the pattern is matched, the I/O unit reacts in a predetermined way. The reaction can turn digital points on or off and can also set bits in the Scratch Pad. You can configure up to 128 digital events and reactions.</p>
<p>See Chapter 2 - Using Digital Events and Reactions in the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nEvent</td><td>Integer from 0 to 127 (inclusive) identifying which event reaction to configure. </td></tr>
    <tr><td class="paramname">Data</td><td>An <a class="el" href="a00018.html">SIOMM_DigitalEventConfigArea</a> instance to configure the event reaction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the event configuration was written successfully </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a2689478ce4b9a316bcfc4df20a3a5f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigPtConfiguration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFeature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a digital point. </p>
<p>This method does two things:</p><ul>
<li>Configures the point's type, the same thing that ConfigurePoint does.</li>
<li>Sets point features. See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for feature values.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">nPointType</td><td>Point type value. A digital output is type 0x180, an input is 0x100. </td></tr>
    <tr><td class="paramname">nFeature</td><td>Feature to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point was configured successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d63812852189001823740d90edfd902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigPtCounterState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn counters on or off for a digital point. </p>
<p>Note: This method works only for standard density digital points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">nState</td><td>0 to turn counters off, non-zero to turn them on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a2029543875d463f73e0444ba72988c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetDigPtState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of a digital point. </p>
<p>(e.g. on/off)</p>
<p>Note: This method works only for standard density digital points. High density digital points must use SetHDDigitalPointState.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to read. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">nState</td><td>Value to set for the digital point's state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a98f418c2ee601cdbc685eb8a36a06880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetEventMsgConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00023.html">SIOMM_EventMsgConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure an event message. </p>
<p>Some OptoMMP devices may be configured to send a message via email, data streaming, SNMP or a serial module when a specific event occurs.</p>
<p>See Chapter 2 - Setting Up Event Messages in the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nMsg</td><td>Integer between 0 and 127 (inclusive) indicating which message slot to configure </td></tr>
    <tr><td class="paramname">Data</td><td>An <a class="el" href="a00023.html">SIOMM_EventMsgConfigArea</a> instance with the data needed to configure the event message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the message configuration write completed successfully </dd>
<dd>
Other values possibly resulting from a call to WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aeac5d970e7941b07abe9fada0e366acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetHDDigitalPointState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of a high-density digital point. </p>
<p>(e.g. on/off)</p>
<p>Note: This method works only for high density digital points. High density digital points must use SetDigPtState.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a2029543875d463f73e0444ba72988c0c" title="Set the state of a digital point. ">SetDigPtState</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the point to be written resides on. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to written to. </td></tr>
    <tr><td class="paramname">nState</td><td>Value to set for the digital point's state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point state was set successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a144e356e1a1bf5428115762a288ea8e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPidLoopConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00026.html">SIOMM_PidLoopConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a PID (proportional/integral/derivative) loop to run on the I/O unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00026.html">SIOMM_PidLoopConfigArea</a> for more details on how to configure PID loops. See KB82058 at www.opto22.com. Firmware 9.4c and later have updated algorithms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPid</td><td>Which PID loop to configure. The number of available PID loops depends on the I/O unit. </td></tr>
    <tr><td class="paramname">Data</td><td>A <a class="el" href="a00026.html">SIOMM_PidLoopConfigArea</a> instance containing the PID loop configuration data you wish to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if everything worked correctly. </dd>
<dd>
Errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d40e6732fce3373bd7e0d200d7045f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointConfigurationEx4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">SIOMM_PointConfigArea4</a>&#160;</td>
          <td class="paramname"><em>PtConfigData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the full configuration data for a given point. </p>
<p>See Appendix A - (Expanded) Analog &amp; Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set configuration for. </td></tr>
    <tr><td class="paramname">PtConfigData</td><td><a class="el" href="a00030.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea4</a> instance holding the configuration for this point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the configuration was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fca4fff98fac62f58ebe14fb7639adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointFeatureEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointFeature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a point's feature. </p>
<p>Works with devices with firmware version 8.0 or newer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Module position of where the point resides. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point index (starting from zero) on the module. </td></tr>
    <tr><td class="paramname">nPointFeature</td><td>Feature to set the point. For volatile features, this value turns to zero when complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a28533a6ba654d7214814238851d4a8a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointFilterWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fFilterWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an analog point's filter weight. </p>
<p>SNAP Analog I/O channels may use a filter weight to smooth analog input signals that are erratic or change suddenly. The formula used for filtering is Y = ( X - Y )/W + Y, where Y is the filtered value, X is the new unfiltered value, and W is the filter weight.</p>
<p>A filter weight of 0 turns off the calculation. Values less than or equal to 0.5 are changed to 0, since those values would cause an unstable signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set configuration for. </td></tr>
    <tr><td class="paramname">fFilterWeight</td><td>Filter weight value to set for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point's configuration was written successfully </dd>
<dd>
Other errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb24c2703c196ab49cba5d054475a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointGain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fGain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an analog point's gain value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set configuration for. </td></tr>
    <tr><td class="paramname">fGain</td><td>Filter weight value to set for the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point's configuration was written successfully </dd>
<dd>
Other errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="ae7120935e6a23dc4bf75815de92f0820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pchPointName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user-friendly name for a point. </p>
<p>A point's name is limited to 51 characters, including a NULL byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the point to be named resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set a name for </td></tr>
    <tr><td class="paramname">pchPointName</td><td>C-string holding the point's name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point's name was written successfully </dd>
<dd>
SIOMM_ERROR if pchPointName is NULL </dd>
<dd>
Other errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="af4ec200201f3995f03ea633bbe79cf87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an analog point's offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set the offset value for </td></tr>
    <tr><td class="paramname">fOffset</td><td>Offset value to set on the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point's configuration was written successfully </dd>
<dd>
Errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a545e8c3eb58ead08ff87df458061ff2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fHiScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fLoScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scaling values for an analog point. </p>
<p>You can scale analog input or output points to match your needs. For example, you can scale a -5 V to +5 V input point to reflect 0% to 100%. Point types may be unipolar or bipolar.</p>
<p>See Chapter 2 - Scaling (Analog Points) of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set scaling values for </td></tr>
    <tr><td class="paramname">fHiScale</td><td>High value to use for scaling </td></tr>
    <tr><td class="paramname">fLoScale</td><td>Low value to use for scaling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point's scaling values were written successfully </dd>
<dd>
Errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="abac330577bbfad76f28b8c28ded9284d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPointWatchdog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a watchdog for a point. </p>
<p>A watchdog monitors communication on the OptoMMP port. If nothing accesses the port for the length of time set in the watchdog, the I/O unit automatically sets designated digital and analog I/O points to the values you have determined.</p>
<p>A watchdog helps make sure that a communication failure doesnt result in disaster. If communication fails between the host and the I/O unit controlling a process, the watchdog makes sure the process is automatically brought to a safe state. For example, a valve could automatically close to avoid completely emptying a tank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nModule</td><td>Which module the targeted point resides on </td></tr>
    <tr><td class="paramname">nPoint</td><td>Point number on the module to set watchdog parameters for </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set the point to if communications fail </td></tr>
    <tr><td class="paramname">nEnabled</td><td>Turn the watchdog on or off. 0 means off, non-zero means on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point was configured successfully. </dd>
<dd>
Errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a313b4eb29413114c19e6d9fceff794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPtConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00027.html">SIOMM_PointConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the full configuration for a given point. </p>
<p>NOTE: This method is deprecated, use SetPtConfigurationEx3 instead.</p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a3ae32b691650b63e3b548697f98e1019" title="Set the full configuration for a given point. ">SetPtConfigurationEx3</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">Data</td><td><a class="el" href="a00027.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea</a> instance filled out with the point's full configuration details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a1668052209bef6021c1c05b1a0b09b19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPtConfigurationEx2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">SIOMM_PointConfigArea2</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the full configuration for a given point. </p>
<p>NOTE: This method is deprecated, use SetPtConfigurationEx3 instead.</p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a3ae32b691650b63e3b548697f98e1019" title="Set the full configuration for a given point. ">SetPtConfigurationEx3</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">Data</td><td><a class="el" href="a00028.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea2</a> instance filled out with the point's full configuration details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ae32b691650b63e3b548697f98e1019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPtConfigurationEx3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00029.html">SIOMM_PointConfigArea3</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the full configuration for a given point. </p>
<p>See Appendix A - (Old) Analog and Digital Point Configuration Information - Read/Write of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">Data</td><td><a class="el" href="a00029.html" title="Point configuration read/write area. ">SIOMM_PointConfigArea3</a> instance filled out with the point's full configuration details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully. </dd>
<dd>
Other errors possibly resulting from ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ad627356f69630819afa283e3215a52ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetPtWatchdog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a watchdog value for a point. </p>
<p>A watchdog monitors communication on the OptoMMP port. If nothing accesses the port for the length of time set in the watchdog, the I/O unit automatically sets designated digital and analog I/O points to the values you have determined.</p>
<p>A watchdog helps make sure that a communication failure doesnt result in disaster. If communication fails between the host and the I/O unit controlling a process, the watchdog makes sure the process is automatically brought to a safe state. For example, a valve could automatically close to avoid completely emptying a tank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoint</td><td>Point number on the I/O unit to configure. Typically, this will be the module slot on the rack multiplied by 4, plus the point number on that module. </td></tr>
    <tr><td class="paramname">fValue</td><td>Value to set the point to if communications fail </td></tr>
    <tr><td class="paramname">nEnabled</td><td>Turn the watchdog on or off. 0 means off, non-zero means on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the point was configured successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="af461662178bb18fcdb9a4ba7d24cedf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetScratchPadBitArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBits63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBits31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I/O unit's scratchpad bits area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nBits63to32</td><td>Bitmask to set for bits 32-63 </td></tr>
    <tr><td class="paramname">nBits31to0</td><td>Bitmask to set for bits 0-31 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the scratpchpad area was set successfully </dd>
<dd>
Errors possibly resulting from a call to WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a69c697c8eea8250f2eac536d2e5ca782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetScratchPadBitAreaMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOnMask63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOnMask31to0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOffMask63to32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOffMask31to0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I/O unit's scratchpad area. </p>
<p>This method allows the caller to conditionally set bits in the scratchpad area. Any bit location set to 1 in nOnMask* arguments will be set ON, others will be left untouched. Any bit location set to 1 in the nOffMask* arguments will be set OFF, others will be left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nOnMask63to32</td><td>Bitmask of locations to set ON, bits 32-63 </td></tr>
    <tr><td class="paramname">nOnMask31to0</td><td>Bitmask of locations to set ON, bits 0-31 </td></tr>
    <tr><td class="paramname">nOffMask63to32</td><td>Bitmask of locations to set OFF, bits 32-63 </td></tr>
    <tr><td class="paramname">nOffMask31to0</td><td>Bitmask of locations to set OFF, bits 0-31 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the scratchpad area was written to successfully </dd>
<dd>
Errors possibly resulting from a call to WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="ac3bded96663999d82e981a9542dfe0cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetScratchPadFloatArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the I/O unit's float scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the float scratchpad location to begin writing to </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in float locations) of the data to write </td></tr>
    <tr><td class="paramname">pfData</td><td>Pointer to a user-supplied buffer of data to write. Must be nLength * 4 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully </dd>
<dd>
SIOMM_ERROR if pnData was NULL </dd>
<dd>
Other errors possibly resulting from a call to WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a05a71425c11813d75b7a8161a5ef689e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetScratchPadInteger64Area </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the I/O unit's 64-bit integer scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the 64-bit integer scratchpad location to begin writing to </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in integer locations) of the data to write </td></tr>
    <tr><td class="paramname">pnData</td><td>Pointer to a user-supplied buffer of data to write. Must be nLength * 8 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully </dd>
<dd>
SIOMM_ERROR if pnData was NULL </dd>
<dd>
Other errors possibly resulting from a call to WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a04d6b0ddc17af9ff0067bc95e2794001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetScratchPadIntegerArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the I/O unit's integer scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the integer scratchpad location to begin writing to </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in integer locations) of the data to write </td></tr>
    <tr><td class="paramname">pnData</td><td>Pointer to a user-supplied buffer of data to write. Must be nLength * 4 bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully </dd>
<dd>
SIOMM_ERROR if pnData was NULL </dd>
<dd>
Other errors possibly resulting from a call to WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="aacd292d7e5ee5af67f93f0c542cfc967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetScratchPadStringArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00035.html">SIOMM_ScratchPadString</a> *&#160;</td>
          <td class="paramname"><em>pStringData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the I/O unit's string scratch pad area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nStartIndex</td><td>Index of the string scratchpad location to begin reading from </td></tr>
    <tr><td class="paramname">nLength</td><td>Length (in string locations) of the data to read </td></tr>
    <tr><td class="paramname">pStringData</td><td>Array of <a class="el" href="a00035.html">SIOMM_ScratchPadString</a> instances to write to the I/O units string scratchpad. Must be sizeof(SIOMM_ScratchPadString) * nLength bytes in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was read successfully </dd>
<dd>
SIOMM_ERROR if pStringData was NULL </dd>
<dd>
Other errors possibly resulting from a call to ReadBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a780b0c82ce26a9c7f28c9b0a54cee33a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetSerialEventConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00036.html">SIOMM_SerialEventConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure reactions in response to serial events. </p>
<p>See Chapter 2 - Using Serial Events and Reactions of the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nEvent</td><td>Index of the serial event to configure </td></tr>
    <tr><td class="paramname">Data</td><td>An <a class="el" href="a00036.html">SIOMM_SerialEventConfigArea</a> instance to use to configure the serial reaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the serial event configuration was written successfully </dd>
<dd>
Other errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a306a324f084717a9dbdf4a28f17d5133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetSerialModuleConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSerialPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00037.html">SIOMM_SerialModuleConfigArea</a>&#160;</td>
          <td class="paramname"><em>ConfigData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write configuration data for a SNAP serial communication module. </p>
<p>See Appendix A - Serial Module Configuration - Read/Write of the Opto MMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSerialPort</td><td>Which serial port to configure. See Appendix A - Serial Module Configuration - Read/Write for how port numbers are determined. </td></tr>
    <tr><td class="paramname">ConfigData</td><td><a class="el" href="a00037.html">SIOMM_SerialModuleConfigArea</a> structure instance with the data to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a652d879d816219fd91766b64941e8650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStatusBootpRequest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I/O unit to send BootP or DHCP request when turned on. </p>
<p>Possible values for nFlag:</p><ul>
<li>0 Send BootP or DHCP request only if device's IP address is 0.0.0.0.</li>
<li>1 Always send BootP or DHCP request when device is turned on.</li>
</ul>
<p>See Appendix A - Status Area Write in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nFlag</td><td>BootP request flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a648312735cd629ea266e3a6da2044e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStatusDegrees </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDegFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the I/O unit to report temperatures in degrees Celsius or degrees Fahrenheit. </p>
<p>Possible values for nDegFlag:</p><ul>
<li>0 Report temperatures in degrees Celsius. (this is the default)</li>
<li>1 Report temperatures in degrees Fahrenheit.</li>
</ul>
<p>See Appendix A - Status Area Write in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nDegFlag</td><td>Option to set for reporting temperatures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="aca8ffd2fc7f4e096b6d7b30fce99e320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStatusOperation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOpCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given opcode to the SIOMM_STATUS_WRITE_OPERATION location in the I/O units memory map. </p>
<p>Some example opcodes are:</p><ul>
<li>0x00000001 - Send Powerup Clear</li>
<li>0x00000002 - Reset to defaults</li>
<li>0x00000003 - Store all configuration data to flash.</li>
</ul>
<p>See Appendix A - Status Area Write in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nOpCode</td><td>Opcode to write to the SIOMM_STATUS_WRITE_OPERATION location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a0512ce0ea20da408febac0ae4d65e684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStatusWatchdogTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTimeMS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set watchdog time in milliseconds. </p>
<p>A value of 0 disables the watchdog. Any other positive value sets the watchdog time in milliseconds. Negative values are an error.</p>
<p>See Appendix A - Status Area Write in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTimeMS</td><td>Watchdog time in milliseconds. (Must be &gt;= 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a9531e5a2cc65b74b3a6d7d532a548ab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStatusWriteEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">SIOMM_StatusWrite</a>&#160;</td>
          <td class="paramname"><em>StatusWriteData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write new data to the Status Read/Write area of the I/O unit. </p>
<p>See Appendix A - Status Area Write in the OptoMMP Protocol Guide for additional details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StatusWriteData</td><td>A <a class="el" href="a00043.html">SIOMM_StatusWrite</a> structure holding the data to be written to the Status Write area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the data was written successfully. </dd>
<dd>
Other errors possibly resulting from WriteBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="ac021826c3feb30b18c1f5ec554636d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStreamConfiguration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOnFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIntervalMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIoMirroringEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the IO units current streaming configuration. </p>
<p>Only some OptoMMP devices support this function.</p>
<p>Streaming allows your application to get continuous information from a OptoMMP device without the need to continually poll it.</p>
<p>See Chapter 2 - Streaming Data in the OptoMMP Protocol Guide for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nOnFlag</td><td>Whether or not streaming is enabled. 0 is off, non-zero is on. </td></tr>
    <tr><td class="paramname">nIntervalMS</td><td>Streaming interval, in milliseconds </td></tr>
    <tr><td class="paramname">nPort</td><td>IP port number to stream to </td></tr>
    <tr><td class="paramname">nIoMirroringEnabled</td><td>Whether I/O mirroring is enabled. 0 is off, non-zero is on. </td></tr>
    <tr><td class="paramname">nStartAddress</td><td>Beginning address of the data to be streamed </td></tr>
    <tr><td class="paramname">nDataSize</td><td>Size of data to be streamed. Maximum size is 1480 bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the streaming configuration was read successfully. </dd>
<dd>
Errors possibly resulting from a call to ReadBlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a550f970cf36948e5ead1f45652721166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetStreamTarget </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pchIpAddressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the IP address for a streaming target. </p>
<p>The IP address is passed as a string in dotted number notation, e.g. "1.2.3.4". The passed string must be an IP adddress; the method does not perform hostname lookups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTarget</td><td>Index of the streaming target to set the IP address for. (1-8) </td></tr>
    <tr><td class="paramname">pchIpAddressArg</td><td>IP address to set as a dotted string (e.g. "1.2.3.4") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if the IP address was set successfully </dd>
<dd>
SIOMM_ERROR if pchIpAddressArg is NULL </dd>
<dd>
Other errors possibly resulting from a call to WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a57d7ee448d09dd63a5a9fc1ddd22b942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::SetTimerEventConfigurationEx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00046.html">SIOMM_TimerEventConfigArea</a>&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a timer event. </p>
<p>Note: Only supported on firmware versions 8.0 and older.</p>
<p>See Appendix A - Digital Events - Expanded (Formerly Timers) of the OptoMMP Protocol Guide for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nEvent</td><td>Index of the timer event to configure </td></tr>
    <tr><td class="paramname">Data</td><td>An <a class="el" href="a00046.html">SIOMM_TimerEventConfigArea</a> instance used to configure the timer event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ if the timer event configuration was written successfully </dd>
<dd>
Errors possibly resulting from WriteBlock </dd></dl>

</div>
</div>
<a class="anchor" id="a738db224f75f0e8b2120ffaabe2f62bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::UnpackReadBlockResponse </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyReadBlockResponse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyTransactionLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyResponseCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pwDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyBlockData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks a read response. </p>
<p>This is an internally used utility method to build a read request. Client code isn't likely to need it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbyReadBlockResponse</td><td>Response packet from the server </td></tr>
    <tr><td class="paramname">pbyTransactionLabel</td><td>User supplied pointer to a uint8_t to hold the transaction label from the packet </td></tr>
    <tr><td class="paramname">pbyResponseCode</td><td>User supplied pointer to a uint8_t to hold the response code from the packet. </td></tr>
    <tr><td class="paramname">pwDataLength</td><td>User supplied pointer to a uint16_t to hold the length of the data in the response packet </td></tr>
    <tr><td class="paramname">pbyBlockData</td><td>User supplied pointer to hold the data from the read request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR if any inputs are NULL, SIOMM_ERROR_INCORRECT_TCODE_RECIEVED if the packet isn't valid, SIOMM_OK otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a35c7b6b1c59b0bd1adf591733a3d9f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::UnpackWriteResponse </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyWriteQuadletResponse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyTransactionLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyResponseCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks a write response packet. </p>
<p>This is an internally used utility method; client code isn't likely to need it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbyWriteQuadletResponse</td><td>Response packet from the server. </td></tr>
    <tr><td class="paramname">pbyTransactionLabel</td><td>User supplied pointer to a uint8_t to hold the transaction label from the packet </td></tr>
    <tr><td class="paramname">pbyResponseCode</td><td>User supplied pointer to a uint8_t to hold the response code from the packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_ERROR if any of the input parameters are NULL, or if this is not a write response packet. SIOMM_OK otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ada3f1044e5ef9bc8da8cec03136a9fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::WriteBlock </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a block of data to the I/O unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to write data to </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of memory to write (e.g. pbyData), in bytes </td></tr>
    <tr><td class="paramname">pbyData</td><td>Data to write to the brain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if data was written successfully. </dd>
<dd>
SIOMM_ERROR if pbyData is NULL. </dd>
<dd>
Other errors depending on what sort of connection you're using. (Ethernet, Serial, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="a38edcee14fb6d62586953abdbd56af87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::WriteBlockAsFloats </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an array of floats to the I/O unit. </p>
<p>This is a wrapper for WriteBlock</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ada3f1044e5ef9bc8da8cec03136a9fa1" title="Writes a block of data to the I/O unit. ">WriteBlock</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to write data to </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of the array of float in pnData. (Not length in bytes). </td></tr>
    <tr><td class="paramname">pfData</td><td>Array of floats to write to the I/O unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if data was written successfully. </dd>
<dd>
SIOMM_ERROR if pnData is NULL. </dd>
<dd>
Other errors depending on what sort of connection you're using. (e.g. Ethernet, Serial, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="ab993a491a7999ef681feee4252d54ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::WriteBlockAsIntegers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an array of integers to the I/O unit. </p>
<p>This is a wrapper for WriteBlock</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ada3f1044e5ef9bc8da8cec03136a9fa1" title="Writes a block of data to the I/O unit. ">WriteBlock</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to write data to </td></tr>
    <tr><td class="paramname">wDataLength</td><td>Length of the array of integers in pnData. (Not length in bytes). </td></tr>
    <tr><td class="paramname">pnData</td><td>Array of integers to write to the I/O unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIOMM_OK if data was written successfully. </dd>
<dd>
SIOMM_ERROR if pnData is NULL. </dd>
<dd>
Other errors depending on what sort of connection you're using. (e.g. Ethernet, Serial, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="a819e2e932c403f53fa2842946ae8f808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::WriteBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwOptoMMPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbyary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to memory map. </p>
<p>/param dwOptoMMPAddress lower 32-bits of the OptoMMP address to be written. /param nLength quantity of bytes to write. /param pbyary byte array of data to write. </p>

</div>
</div>
<a class="anchor" id="a9569087f77535891286008e178599e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::WriteFloat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a float (4 bytes) of data to the given offset on the brain. </p>
<p>This is a wrapper for WriteQuad</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to write data to. </td></tr>
    <tr><td class="paramname">fValue</td><td>Data to be written to the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result from the underlying WriteQuad call. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e3dac4dbe900d6c3d07c64012183058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int O22SnapIoMemMap::WriteQuad </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwDestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwQuadlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a quad (4 bytes) of data to the given offset on the brain. </p>
<p>This is a wrapper for WriteBlock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwDestOffset</td><td>Memory map offset to write data to. </td></tr>
    <tr><td class="paramname">dwQuadlet</td><td>Data to be written to the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result from the underlying WriteBlock call. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00051_source.html">O22SIOMM.h</a></li>
<li>O22SIOMM.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 15 2018 13:00:14 for PAC-DEV-OPTOMMP-CPLUS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
